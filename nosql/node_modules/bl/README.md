---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052341"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Estado de compilación](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Objeto Node.js recopilador de listas de búferes, lector y streamer.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** es un objeto de almacenamiento para colecciones de búferes de nodo, a los que expone con la API principal legible de búfer. También funciona como una secuencia dúplex para que pueda recopilar búferes de una secuencia que los emita y emitir búferes a una secuencia que los consuma.

Los búferes originales se mantienen intactos y las copias solo se realizan según sea necesario. Las lecturas que requieran el uso de un único búfer original solo devolverán un segmento de ese búfer (que hace referencia a la misma memoria que el búfer original). Lee que los búferes de intervalo realizan la concatenación según sea necesario y devuelven los resultados de forma transparente.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Asígnele una devolución de llamada en el constructor y úsela como **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Tenga en cuenta que cuando se usa un método de *devolución de llamada* como este, el parámetro resultante `data` es una concatenación de todos los objetos `Buffer` de la lista. Si desea evitar la sobrecarga de esta concatenación (en casos de conciencia extrema de rendimiento), evite el método de *devolución de llamada* y escuche `'end'` en su lugar, como una secuencia estándar.

O para capturar una dirección URL mediante [hyperquest](https://github.com/substack/hyperquest) (debería funcionar con la [solicitud](http://github.com/mikeal/request) e incluso el nodo sin formato http también):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

O bien, úselo como una secuencia legible para recomponer una lista de búferes en un origen de salida:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
No se _requieren_ argumentos para el constructor, pero puede inicializar la lista pasando un solo objeto `Buffer`o una matriz de objetos `Buffer`.

`new` no es estrictamente necesario, si no crea una instancia de un nuevo objeto, se realizará automáticamente para que pueda crear una nueva instancia simplemente con:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Determina si el objeto pasado es `BufferList`. Devolverá `true` si el objeto pasado es una instancia de `BufferList` **o** `BufferListStream` y `false`.

N.B. esto no devolverá `true` para las instancias `BufferList` o `BufferListStream` creadas por las versiones de esta biblioteca antes de agregar este método estático.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Obtener la longitud de la lista, en bytes. Esta es la suma de las longitudes de todos los búferes contenidos en la lista, menos cualquier desplazamiento inicial de un búfer parcialmente consumido al principio. Debe representar con precisión el número total de bytes que se pueden leer de la lista.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` agrega un búfer adicional o BufferList a la lista interna. `this` se devuelve para que se pueda encadenar.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` devolverá el byte en el índice especificado.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` devolverá el byte en el índice especificado.
El método `indexOf()` devuelve el primer índice en el que se puede encontrar un elemento determinado en BufferList o -1 si no está presente.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` devuelve un nuevo objeto `Buffer` que contiene los bytes dentro del intervalo especificado. Tanto `start` como `end` son opcionales y tendrán como valor predeterminado el principio y el final de la lista, respectivamente.

Si el intervalo solicitado abarca un único búfer interno, se devolverá un segmento de ese búfer que comparte el intervalo de memoria original de ese búfer. Si el intervalo abarca varios búferes, es probable que se produzcan operaciones de copia para proporcionarle un búfer uniforme.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` devuelve un nuevo objeto `BufferList` que contiene los bytes dentro del intervalo especificado. Tanto `start` como `end` son opcionales y tendrán como valor predeterminado el principio y el final de la lista, respectivamente.

No se realizará ninguna copia. Todos los búferes del resultado comparten memoria con la lista original.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` copia el contenido de la lista en el búfer `dest`, empezando por `destStart` y con los bytes del intervalo especificado con `srcStart` a `srcEnd`. `destStart`, `start` y `end` son opcionales y tendrán como valor predeterminado el principio del búfer `dest`, y el principio y el final de la lista, respectivamente.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` realiza una **copia superficial** de la lista. Los búferes internos siguen siendo los mismos, por lo que si cambia los búferes subyacentes, el cambio se reflejará tanto en el original como en el duplicado. Este método es necesario si desea llamar a `consume()` o `pipe()` y mantener la lista original. Ejemplo:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` desplazará los bytes *fuera del inicio de la lista*. El número de bytes consumidos no necesita alinearse con los tamaños de los búferes internos; &mdash;los desplazamientos iniciales se calculará en consecuencia para proporcionarle una vista coherente de los datos.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` devolverá una representación de cadena del búfer. Los argumentos opcionales `start` y `end` se pasan a `slice()`, mientras que `encoding` se pasa al `toString()` del búfer resultante. Para más información, consulte la documentación [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end).

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Todos los métodos de lectura de bytes estándar de la interfaz `Buffer` se implementan y funcionarán en los límites internos del búfer de forma transparente.

Consulte la documentación <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> sobre su funcionamiento.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** es un **[flujo dúplex](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** de nodo, por lo que se puede leer y escribir como un flujo de nodo estándar. También puede `pipe()` a y desde una instancia de **BufferListStream**.

El constructor toma una devolución de llamada opcional, si se proporciona, se llamará a la devolución de llamada con un argumento de error seguido de una referencia a la instancia **bl**, cuando se llama a `bl.end()` (es decir, desde una secuencia canalizada). Se trata de un método práctico para recopilar todo el contenido de una secuencia, especialmente cuando la secuencia está *fragmentada*, como una secuencia de red.

Normalmente, no se requieren argumentos para el constructor, pero puede inicializar la lista pasando un solo objeto `Buffer` o una matriz de objetos `Buffer`.

`new` no es estrictamente necesario, si no crea una instancia de un nuevo objeto, se realizará automáticamente para que pueda crear una nueva instancia simplemente con:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. Por motivos de compatibilidad con versiones anteriores, `BufferListStream` es la exportación **predeterminada** cuando :`require('bl')`

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Colaboradores

**bl** está presentado por los siguientes hackers:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Copyright de licencia &amp;

Copyright (c) 2013-2019 colaboradores bl (enumerados anteriormente).

Autorización sujeta a la licencia MIT. Todos los derechos no concedidos explícitamente en la licencia MIT están reservados. Consulte el archivo LICENSE.md incluido para obtener más detalles.
