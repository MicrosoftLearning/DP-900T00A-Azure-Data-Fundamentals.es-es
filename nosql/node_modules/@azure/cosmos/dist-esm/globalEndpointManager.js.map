{"version":3,"file":"globalEndpointManager.js","sourceRoot":"","sources":["../src/globalEndpointManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { OperationType, ResourceType, isReadRequest } from \"./common\";\nimport { CosmosClientOptions } from \"./CosmosClientOptions\";\nimport { Location, DatabaseAccount } from \"./documents\";\nimport { RequestOptions } from \"./index\";\nimport { ResourceResponse } from \"./request\";\n\n/**\n * @hidden\n * This internal class implements the logic for endpoint management for geo-replicated database accounts.\n */\nexport class GlobalEndpointManager {\n  /**\n   * The endpoint used to create the client instance.\n   */\n  private defaultEndpoint: string;\n  /**\n   * Flag to enable/disable automatic redirecting of requests based on read/write operations.\n   */\n  public enableEndpointDiscovery: boolean;\n  private isRefreshing: boolean;\n  private options: CosmosClientOptions;\n  /**\n   * List of azure regions to be used as preferred locations for read requests.\n   */\n  private preferredLocations: string[];\n  private writeableLocations: Location[] = [];\n  private readableLocations: Location[] = [];\n\n  /**\n   * @param options - The document client instance.\n   */\n  constructor(\n    options: CosmosClientOptions,\n    private readDatabaseAccount: (\n      opts: RequestOptions\n    ) => Promise<ResourceResponse<DatabaseAccount>>\n  ) {\n    this.options = options;\n    this.defaultEndpoint = options.endpoint;\n    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;\n    this.isRefreshing = false;\n    this.preferredLocations = this.options.connectionPolicy.preferredLocations;\n  }\n\n  /**\n   * Gets the current read endpoint from the endpoint cache.\n   */\n  public async getReadEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Read);\n  }\n\n  /**\n   * Gets the current write endpoint from the endpoint cache.\n   */\n  public async getWriteEndpoint(): Promise<string> {\n    return this.resolveServiceEndpoint(ResourceType.item, OperationType.Replace);\n  }\n\n  public async getReadEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async getWriteEndpoints(): Promise<ReadonlyArray<string>> {\n    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);\n  }\n\n  public async markCurrentLocationUnavailableForRead(endpoint: string): Promise<void> {\n    await this.refreshEndpointList();\n    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public async markCurrentLocationUnavailableForWrite(endpoint: string): Promise<void> {\n    await this.refreshEndpointList();\n    const location = this.writeableLocations.find(\n      (loc) => loc.databaseAccountEndpoint === endpoint\n    );\n    if (location) {\n      location.unavailable = true;\n    }\n  }\n\n  public canUseMultipleWriteLocations(\n    resourceType?: ResourceType,\n    operationType?: OperationType\n  ): boolean {\n    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;\n\n    if (resourceType) {\n      canUse =\n        canUse &&\n        (resourceType === ResourceType.item ||\n          (resourceType === ResourceType.sproc && operationType === OperationType.Execute));\n    }\n\n    return canUse;\n  }\n\n  public async resolveServiceEndpoint(\n    resourceType: ResourceType,\n    operationType: OperationType\n  ): Promise<string> {\n    // If endpoint discovery is disabled, always use the user provided endpoint\n    if (!this.options.connectionPolicy.enableEndpointDiscovery) {\n      return this.defaultEndpoint;\n    }\n\n    // If getting the database account, always use the user provided endpoint\n    if (resourceType === ResourceType.none) {\n      return this.defaultEndpoint;\n    }\n\n    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {\n      const { resource: databaseAccount } = await this.readDatabaseAccount({\n        urlConnection: this.defaultEndpoint\n      });\n      this.writeableLocations = databaseAccount.writableLocations;\n      this.readableLocations = databaseAccount.readableLocations;\n    }\n\n    const locations = isReadRequest(operationType)\n      ? this.readableLocations\n      : this.writeableLocations;\n\n    let location;\n    // If we have preferred locations, try each one in order and use the first available one\n    if (this.preferredLocations && this.preferredLocations.length > 0) {\n      for (const preferredLocation of this.preferredLocations) {\n        location = locations.find(\n          (loc) =>\n            loc.unavailable !== true &&\n            normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation)\n        );\n        if (location) {\n          break;\n        }\n      }\n    }\n\n    // If no preferred locations or one did not match, just grab the first one that is available\n    if (!location) {\n      location = locations.find((loc) => {\n        return loc.unavailable !== true;\n      });\n    }\n\n    return location ? location.databaseAccountEndpoint : this.defaultEndpoint;\n  }\n\n  /**\n   * Refreshes the endpoint list by retrieving the writable and readable locations\n   *  from the geo-replicated database account and then updating the locations cache.\n   *   We skip the refreshing if enableEndpointDiscovery is set to False\n   */\n  public async refreshEndpointList(): Promise<void> {\n    if (!this.isRefreshing && this.enableEndpointDiscovery) {\n      this.isRefreshing = true;\n      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint();\n      if (databaseAccount) {\n        this.refreshEndpoints(databaseAccount);\n      }\n\n      this.isRefreshing = false;\n    }\n  }\n\n  private refreshEndpoints(databaseAccount: DatabaseAccount): void {\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.writeableLocations.push(location);\n      }\n    }\n    for (const location of databaseAccount.writableLocations) {\n      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);\n      if (!existingLocation) {\n        this.readableLocations.push(location);\n      }\n    }\n  }\n\n  /**\n   * Gets the database account first by using the default endpoint, and if that doesn't returns\n   * use the endpoints for the preferred locations in the order they are specified to get\n   * the database account.\n   */\n  private async getDatabaseAccountFromAnyEndpoint(): Promise<DatabaseAccount> {\n    try {\n      const options = { urlConnection: this.defaultEndpoint };\n      const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n      return databaseAccount;\n      // If for any reason(non - globaldb related), we are not able to get the database\n      // account from the above call to readDatabaseAccount,\n      // we would try to get this information from any of the preferred locations that the user\n      // might have specified (by creating a locational endpoint)\n      // and keeping eating the exception until we get the database account and return None at the end,\n      // if we are not able to get that info from any endpoints\n    } catch (err) {\n      // TODO: Tracing\n    }\n\n    if (this.preferredLocations) {\n      for (const location of this.preferredLocations) {\n        try {\n          const locationalEndpoint = GlobalEndpointManager.getLocationalEndpoint(\n            this.defaultEndpoint,\n            location\n          );\n          const options = { urlConnection: locationalEndpoint };\n          const { resource: databaseAccount } = await this.readDatabaseAccount(options);\n          if (databaseAccount) {\n            return databaseAccount;\n          }\n        } catch (err) {\n          // TODO: Tracing\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets the locational endpoint using the location name passed to it using the default endpoint.\n   *\n   * @param defaultEndpoint - The default endpoint to use for the endpoint.\n   * @param locationName    - The location name for the azure region like \"East US\".\n   */\n  private static getLocationalEndpoint(defaultEndpoint: string, locationName: string): string {\n    // For defaultEndpoint like 'https://contoso.documents.azure.com:443/' parse it to generate URL format\n    // This defaultEndpoint should be global endpoint(and cannot be a locational endpoint)\n    // and we agreed to document that\n    const endpointUrl = new URL(defaultEndpoint);\n\n    // hostname attribute in endpointUrl will return 'contoso.documents.azure.com'\n    if (endpointUrl.hostname) {\n      const hostnameParts = endpointUrl.hostname\n        .toString()\n        .toLowerCase()\n        .split(\".\");\n      if (hostnameParts) {\n        // globalDatabaseAccountName will return 'contoso'\n        const globalDatabaseAccountName = hostnameParts[0];\n\n        // Prepare the locationalDatabaseAccountName as contoso-EastUS for location_name 'East US'\n        const locationalDatabaseAccountName =\n          globalDatabaseAccountName + \"-\" + locationName.replace(\" \", \"\");\n\n        // Replace 'contoso' with 'contoso-EastUS' and\n        // return locationalEndpoint as https://contoso-EastUS.documents.azure.com:443/\n        const locationalEndpoint = defaultEndpoint\n          .toLowerCase()\n          .replace(globalDatabaseAccountName, locationalDatabaseAccountName);\n        return locationalEndpoint;\n      }\n    }\n\n    return null;\n  }\n}\n\nfunction normalizeEndpoint(endpoint: string): string {\n  return endpoint\n    .split(\" \")\n    .join(\"\")\n    .toLowerCase();\n}\n"]}