{"version":3,"file":"batch.js","sourceRoot":"","sources":["../../src/utils/batch.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { JSONObject } from \"../queryExecutionContext\";\nimport { extractPartitionKey } from \"../extractPartitionKey\";\nimport { PartitionKeyDefinition } from \"../documents\";\nimport { RequestOptions } from \"..\";\nimport { v4 as uuid } from \"uuid\";\n\nexport type Operation =\n  | CreateOperation\n  | UpsertOperation\n  | ReadOperation\n  | DeleteOperation\n  | ReplaceOperation;\n\nexport interface Batch {\n  min: string;\n  max: string;\n  rangeId: string;\n  indexes: number[];\n  operations: Operation[];\n}\n\nexport interface OperationResponse {\n  statusCode: number;\n  requestCharge: number;\n  eTag?: string;\n  resourceBody?: JSONObject;\n}\n\n/**\n * Options object used to modify bulk execution.\n * continueOnError (Default value: false) - Continues bulk execution when an operation fails ** NOTE THIS WILL DEFAULT TO TRUE IN the 4.0 RELEASE\n */\nexport interface BulkOptions {\n  continueOnError?: boolean;\n}\n\nexport function isKeyInRange(min: string, max: string, key: string): boolean {\n  const isAfterMinInclusive = key.localeCompare(min) >= 0;\n  const isBeforeMax = key.localeCompare(max) < 0;\n  return isAfterMinInclusive && isBeforeMax;\n}\n\nexport interface OperationBase {\n  partitionKey?: string;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n}\n\nexport const BulkOperationType = {\n  Create: \"Create\",\n  Upsert: \"Upsert\",\n  Read: \"Read\",\n  Delete: \"Delete\",\n  Replace: \"Replace\"\n} as const;\n\nexport type OperationInput =\n  | CreateOperationInput\n  | UpsertOperationInput\n  | ReadOperationInput\n  | DeleteOperationInput\n  | ReplaceOperationInput;\n\nexport interface CreateOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Create;\n  resourceBody: JSONObject;\n}\n\nexport interface UpsertOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Upsert;\n  resourceBody: JSONObject;\n}\n\nexport interface ReadOperationInput {\n  partitionKey?: string | number | boolean | null | Record<string, unknown> | undefined;\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n}\n\nexport interface DeleteOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n}\n\nexport interface ReplaceOperationInput {\n  partitionKey?: string | number | null | Record<string, unknown> | undefined;\n  ifMatch?: string;\n  ifNoneMatch?: string;\n  operationType: typeof BulkOperationType.Replace;\n  resourceBody: JSONObject;\n}\n\nexport type OperationWithItem = OperationBase & {\n  resourceBody: JSONObject;\n};\n\nexport type CreateOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Create;\n};\n\nexport type UpsertOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Upsert;\n};\n\nexport type ReadOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Read;\n  id: string;\n};\n\nexport type DeleteOperation = OperationBase & {\n  operationType: typeof BulkOperationType.Delete;\n  id: string;\n};\n\nexport type ReplaceOperation = OperationWithItem & {\n  operationType: typeof BulkOperationType.Replace;\n  id: string;\n};\n\nexport function hasResource(\n  operation: Operation\n): operation is CreateOperation | UpsertOperation | ReplaceOperation {\n  return (operation as OperationWithItem).resourceBody !== undefined;\n}\n\nexport function getPartitionKeyToHash(operation: Operation, partitionProperty: string): any {\n  const toHashKey = hasResource(operation)\n    ? deepFind(operation.resourceBody, partitionProperty)\n    : (operation.partitionKey && operation.partitionKey.replace(/[[\\]\"']/g, \"\")) ||\n      operation.partitionKey;\n  // We check for empty object since replace will stringify the value\n  // The second check avoids cases where the partitionKey value is actually the string '{}'\n  if (toHashKey === \"{}\" && operation.partitionKey === \"[{}]\") {\n    return {};\n  }\n  if (toHashKey === \"null\" && operation.partitionKey === \"[null]\") {\n    return null;\n  }\n  if (toHashKey === \"0\" && operation.partitionKey === \"[0]\") {\n    return 0;\n  }\n  return toHashKey;\n}\n\nexport function decorateOperation(\n  operation: OperationInput,\n  definition: PartitionKeyDefinition,\n  options: RequestOptions = {}\n): Operation {\n  if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    if (\n      (operation.resourceBody.id === undefined || operation.resourceBody.id === \"\") &&\n      !options.disableAutomaticIdGeneration\n    ) {\n      operation.resourceBody.id = uuid();\n    }\n  }\n  if (\"partitionKey\" in operation) {\n    const extracted = extractPartitionKey(operation, { paths: [\"/partitionKey\"] });\n    return { ...operation, partitionKey: JSON.stringify(extracted) } as Operation;\n  } else if (\n    operation.operationType === BulkOperationType.Create ||\n    operation.operationType === BulkOperationType.Replace ||\n    operation.operationType === BulkOperationType.Upsert\n  ) {\n    const pk = extractPartitionKey(operation.resourceBody, definition);\n    return { ...operation, partitionKey: JSON.stringify(pk) } as Operation;\n  } else if (\n    operation.operationType === BulkOperationType.Read ||\n    operation.operationType === BulkOperationType.Delete\n  ) {\n    return { ...operation, partitionKey: \"[{}]\" };\n  }\n  return operation as Operation;\n}\n\n/**\n * Util function for finding partition key values nested in objects at slash (/) separated paths\n * @hidden\n */\nexport function deepFind<T, P extends string>(document: T, path: P): JSONObject {\n  const apath = path.split(\"/\");\n  let h: any = document;\n  for (const p of apath) {\n    if (p in h) h = h[p];\n    else throw new Error(`Invalid path: ${path} at ${p}`);\n  }\n  return h;\n}\n"]}