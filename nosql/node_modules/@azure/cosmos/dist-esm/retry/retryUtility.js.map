{"version":3,"file":"retryUtility.js","sourceRoot":"","sources":["../../src/retry/retryUtility.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { Constants } from \"../common/constants\";\nimport { sleep } from \"../common/helper\";\nimport { StatusCodes, SubStatusCodes } from \"../common/statusCodes\";\nimport { Response } from \"../request\";\nimport { RequestContext } from \"../request/RequestContext\";\nimport { DefaultRetryPolicy } from \"./defaultRetryPolicy\";\nimport { EndpointDiscoveryRetryPolicy } from \"./endpointDiscoveryRetryPolicy\";\nimport { ResourceThrottleRetryPolicy } from \"./resourceThrottleRetryPolicy\";\nimport { RetryContext } from \"./RetryContext\";\nimport { RetryPolicy } from \"./RetryPolicy\";\nimport { SessionRetryPolicy } from \"./sessionRetryPolicy\";\n\n/**\n * @hidden\n */\ninterface ExecuteArgs {\n  retryContext?: RetryContext;\n  retryPolicies?: RetryPolicies;\n  requestContext: RequestContext;\n  executeRequest: (requestContext: RequestContext) => Promise<Response<any>>;\n}\n\n/**\n * @hidden\n */\ninterface RetryPolicies {\n  endpointDiscoveryRetryPolicy: EndpointDiscoveryRetryPolicy;\n  resourceThrottleRetryPolicy: ResourceThrottleRetryPolicy;\n  sessionReadRetryPolicy: SessionRetryPolicy;\n  defaultRetryPolicy: DefaultRetryPolicy;\n}\n\n/**\n * @hidden\n */\nexport async function execute({\n  retryContext = {},\n  retryPolicies,\n  requestContext,\n  executeRequest\n}: ExecuteArgs): Promise<Response<any>> {\n  // TODO: any response\n  if (!retryPolicies) {\n    retryPolicies = {\n      endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.operationType\n      ),\n      resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(\n        requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount,\n        requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds,\n        requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds\n      ),\n      sessionReadRetryPolicy: new SessionRetryPolicy(\n        requestContext.globalEndpointManager,\n        requestContext.resourceType,\n        requestContext.operationType,\n        requestContext.connectionPolicy\n      ),\n      defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType)\n    };\n  }\n  if (retryContext && retryContext.clearSessionTokenNotAvailable) {\n    requestContext.client.clearSessionToken(requestContext.path);\n  }\n  requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(\n    requestContext.resourceType,\n    requestContext.operationType\n  );\n  try {\n    const response = await executeRequest(requestContext);\n    response.headers[Constants.ThrottleRetryCount] =\n      retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n    response.headers[Constants.ThrottleRetryWaitTimeInMs] =\n      retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n    return response;\n  } catch (err) {\n    // TODO: any error\n    let retryPolicy: RetryPolicy = null;\n    const headers = err.headers || {};\n    if (\n      err.code === StatusCodes.ENOTFOUND ||\n      err.code === \"REQUEST_SEND_ERROR\" ||\n      (err.code === StatusCodes.Forbidden &&\n        (err.substatus === SubStatusCodes.DatabaseAccountNotFound ||\n          err.substatus === SubStatusCodes.WriteForbidden))\n    ) {\n      retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;\n    } else if (err.code === StatusCodes.TooManyRequests) {\n      retryPolicy = retryPolicies.resourceThrottleRetryPolicy;\n    } else if (\n      err.code === StatusCodes.NotFound &&\n      err.substatus === SubStatusCodes.ReadSessionNotAvailable\n    ) {\n      retryPolicy = retryPolicies.sessionReadRetryPolicy;\n    } else {\n      retryPolicy = retryPolicies.defaultRetryPolicy;\n    }\n    const results = await retryPolicy.shouldRetry(err, retryContext, requestContext.endpoint);\n    if (!results) {\n      headers[Constants.ThrottleRetryCount] =\n        retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;\n      headers[Constants.ThrottleRetryWaitTimeInMs] =\n        retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;\n      err.headers = { ...err.headers, ...headers };\n      throw err;\n    } else {\n      requestContext.retryCount++;\n      const newUrl = (results as any)[1]; // TODO: any hack\n      if (newUrl !== undefined) {\n        requestContext.endpoint = newUrl;\n      }\n      await sleep(retryPolicy.retryAfterInMs);\n      return execute({\n        executeRequest,\n        requestContext,\n        retryContext,\n        retryPolicies\n      });\n    }\n  }\n}\n"]}