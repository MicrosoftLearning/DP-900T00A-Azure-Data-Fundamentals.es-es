---
ms.openlocfilehash: cbc289a6b02d7acb0ad82e3a95bde8846fcff55e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052001"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>[![Estado de compilación](https://secure.travis-ci.org/brianloveswords/node-jws.png)](http://travis-ci.org/brianloveswords/node-jws) de node-jws

Una implementación de [JSON Web Signatures](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html).

Esto se desarrolló con `draft-ietf-jose-json-web-signature-08` e implementa toda la especificación **excepto** la firma o comprobación de la cadena de certificados X.509 (revisiones de bienvenida).

Hay API sincrónicas (`jws.sign`, `jws.verify`) y de streaming (`jws.createSign`, `jws.createVerify`).

# <a name="install"></a>Instalar

```bash
$ npm install jws
```

# <a name="usage"></a>Uso

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

Matriz de algoritmos admitidos. Actualmente se admiten los siguientes algoritmos.

Valor de parámetro alg | Firma digital o algoritmo MAC
----------------|----------------------------
HS256 | HMAC que usa el algoritmo hash SHA-256
HS384 | HMAC que usa el algoritmo hash SHA-384
HS512 | HMAC que usa el algoritmo hash SHA-512
RS256 | RSASSA que usa el algoritmo hash SHA-256
RS384 | RSASSA que usa el algoritmo hash SHA-384
RS512 | RSASSA que usa el algoritmo hash SHA-512
PS256 | RSASSA-PSS que usa el algoritmo hash SHA-256
PS384 | RSASSA-PSS que usa el algoritmo hash SHA-384
PS512 | RSASSA-PSS que usa el algoritmo hash SHA-512
ES256 | ECDSA que usa la curva P-256 y el algoritmo hash SHA-256
ES384 | ECDSA que usa la curva P-384 y el algoritmo hash SHA-384
ES512 | ECDSA que usa la curva P-521 y el algoritmo hash SHA-512
ninguno | No se incluye ninguna firma digital ni valor MAC

## <a name="jwssignoptions"></a>jws.sign(options)

(Sincrónica) Devuelve una firma web JSON para un encabezado y una carga.

Opciones:

* `header`
* `payload`
* `secret` o `privateKey`
* `encoding` (Opcional, el valor predeterminado es "utf8")

`header` debe ser un objeto con una propiedad `alg`. `header.alg` debe ser un valor que se encuentra en `jws.ALGORITHMS`. Consulte arriba la tabla de algoritmos admitidos.

Si `payload` no es un búfer o una cadena, se forzará en una cadena mediante `JSON.stringify`.

Ejemplo

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

(Sincrónica) Devuelve `true` o `false` si una firma coincide con un secreto o una clave.

`signature` es una firma JWS. `header.alg` debe ser un valor que se encuentra en `jws.ALGORITHMS`.
Consulte arriba la tabla de algoritmos admitidos. `secretOrKey` es una cadena o un búfer que contiene el secreto de los algoritmos HMAC o la clave pública codificada PEM para RSA y ECDSA.

Tenga en cuenta que se omite el valor `"alg"` del encabezado de firma.


## <a name="jwsdecodesignature"></a>jws.decode(signature)

(Sincrónica) Devuelve el encabezado descodificado, la carga descodificada y las partes de firma de la firma JWS.

Devuelve un objeto con tres propiedades, por ejemplo,
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

Devuelve un objeto SignStream.

Opciones:

* `header` (obligatorio)
* `payload`
* `key` || `privateKey` || `secret`
* `encoding` (Opcional, el valor predeterminado es "utf8")

Aparte de `header`, todas las opciones esperan una cadena o un búfer cuando el valor se conoce con antelación, o una secuencia para mayor comodidad.
`key`/`privateKey`/`secret` también puede ser un objeto cuando se usa una clave privada cifrada, consulte la [documentación criptográfica][encrypted-key-docs].

Ejemplo:

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

Devuelve un objeto nuevo VerifyStream.

Opciones:

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding` (Opcional, el valor predeterminado es "utf8")

Todas las opciones esperan una cadena o un búfer cuando el valor se conoce con antelación, o una secuencia para mayor comodidad.

Ejemplo:

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>Clase: SignStream

Una clase `Readable Stream` que emite un único evento de datos (la firma calculada) cuando ha terminado.

### <a name="event-done"></a>Evento: "listo"
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

Una clase `Writable Stream` que espera la carga de JWS. *No* usar si ha pasado una opción `payload` al constructor.

Ejemplo:

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

Un objeto `Writable Stream`. Espera el secreto JWS para HMAC o privateKey para ECDSA y RSA. *No* usar si ha pasado una opción `secret` o `key` al constructor.

Ejemplo:

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>Clase: VerifyStream

Se trata de una clase `Readable Stream` que emite un único evento de datos, el resultado de si esa firma era válida o no.

### <a name="event-done"></a>Evento: "listo"
`function (valid, obj) { }`

`valid` es un valor booleano sobre si la firma es válida o no.

### <a name="verifiersignature"></a>verifier.signature

Una clase `Writable Stream` que espera una firma JWS. *No* usar si ha pasado una opción `signature` al constructor.

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

Una clase `Writable Stream` que espera una clave pública o un secreto. *No* usar si ha pasado una opción `key` o `secret` al constructor.

# <a name="todo"></a>TODO

* Parece que debe haber algunas opciones o API que resulten útiles para definir el algoritmo, en lugar de tener que definir un objeto de encabezado con `{ alg: 'ES512' }` o lo que sea cada vez.

* Compatibilidad con X.509, ugh

# <a name="license"></a>Licencia

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
