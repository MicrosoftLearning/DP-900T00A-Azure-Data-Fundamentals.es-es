---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052430"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Compilar** | **Dependencia** |
|-----------|---------------|
| [![Estado de la compilación](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Estado de dependencia](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Implementación de [JSON Web Tokens](https://tools.ietf.org/html/rfc7519).

Esto se desarrolló en función de `draft-ietf-oauth-json-web-token-08`. Hace uso de [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>Instalar

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Notas de migración

* [De v7 a v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Uso

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Asincrónico) Si se proporciona una devolución de llamada, se llama a la devolución de llamada con `err` o con el JWT.

(Sincrónica) Devuelve el JsonWebToken como cadena

`payload` podría ser un literal de objeto, un búfer o una cadena que representa un JSON válido. 
> **Tenga _en cuenta_ que** `exp` o cualquier otra notificación solo se establece si la carga es un literal de objeto. Las cargas de búfer o de cadena no se comprueban en cuanto a la validez de JSON.

> Si `payload` no es un búfer o una cadena, se forzará en una cadena mediante `JSON.stringify`.

`secretOrPrivateKey` es una cadena, un búfer o un objeto que contiene el secreto de los algoritmos HMAC o la clave privada codificada PEM para RSA y ECDSA. En el caso de una clave privada con frase de contraseña, se puede usar un objeto `{ key, passphrase }` (basado en [la documentación criptográfica](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)), en este caso asegúrese de pasar la opción `algorithm`.

`options`:

* `algorithm` (predeterminado: `HS256`)
* `expiresIn`: expresado en segundos o una cadena que describe un intervalo de tiempo [zeit/ms](https://github.com/zeit/ms). 
  > Por ejemplo: `60`, `"2 days"`, `"10h"`, `"7d"`. Un valor numérico se interpreta como un recuento de segundos. Si usa una cadena, asegúrese de proporcionar las unidades de tiempo (días, horas, etc.), de lo contrario, se usa la unidad de milisegundos de forma predeterminada (`"120"` es igual a `"120ms"`).
* `notBefore`: expresado en segundos o una cadena que describe un intervalo de tiempo [zeit/ms](https://github.com/zeit/ms). 
  > Por ejemplo: `60`, `"2 days"`, `"10h"`, `"7d"`. Un valor numérico se interpreta como un recuento de segundos. Si usa una cadena, asegúrese de proporcionar las unidades de tiempo (días, horas, etc.), de lo contrario, se usa la unidad de milisegundos de forma predeterminada (`"120"` es igual a `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: si es verdadero, la función sign modificará el objeto de carga directamente. Esto es útil si necesita una referencia sin procesar a la carga después de que se hayan aplicado notificaciones, pero antes de que se haya codificado en un token.



> No hay valores predeterminados para `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  Estas notificaciones también se pueden proporcionar en la carga directamente con `exp`, `nbf`, `aud`, `sub`y `iss` respectivamente, pero **_no se puede_** incluir en ambos lugares.

Recuerde que `exp`, `nbf` y `iat` son **NumericDate**, consulte [Expiración de tokens (notificación exp)](#token-expiration-exp-claim)


El encabezado se puede personalizar a través del objeto `options.header`.

Los jwts generados incluirán una notificación `iat` (emitida en) de forma predeterminada, a menos que `noTimestamp` se especifique. Si `iat` se inserta en la carga, se usará en lugar de la marca de tiempo real para calcular otras cosas, como `exp` un intervalo de tiempo en `options.expiresIn`.

Sign sincrónico con el valor predeterminado (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Signo sincrónico con RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Sign asincrónico
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Atrasar jwt 30 segundos
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Expiración del token (notificación exp)

El estándar para JWT define una notificación `exp` para la expiración. La expiración se representa como **NumericDate**:

> Valor numérico JSON que representa el número de segundos desde 1970-01-01T00:00:00Z UTC hasta la fecha y hora UTC especificada, ignorando los segundos intercalados.  Esto equivale a la definición IEEE Std 1003.1, 2013 Edition [POSIX.1] "Segundos desde la época", en la que cada día se contabiliza exactamente como 86400 segundos, salvo porque los valores no enteros se pueden representar.  Consulte RFC 3339 [RFC3339] para más información acerca de la fecha y hora en general, y la hora UTC en particular.

Esto significa que el campo `exp` debe contener el número de segundos desde la época.

Firma de un token con una hora de expiración:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Otra manera de generar un token como este con esta biblioteca es:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Asincrónico) Si se proporciona una devolución de llamada, la función actúa de forma asincrónica. Se llama a la devolución de llamada con la carga descodificada si la firma es válida y la expiración opcional, la audiencia o el emisor son válidos. Si no es así, se llamará con el error.

(Sincrónico) Si no se proporciona una devolución de llamada, la función actúa de forma sincrónica. Devuelve la carga descodificada si la firma es válida y la expiración opcional, audiencia o emisor son válidas. Si no es así, se producirá el error.

`token` es la cadena JsonWebToken

`secretOrPublicKey` es una cadena o un búfer que contiene el secreto de los algoritmos HMAC o la clave pública codificada PEM para RSA y ECDSA.
Si `jwt.verify` se llama de forma asincrónica, `secretOrPublicKey` puede ser una función que debería capturar el secreto o la clave pública. Consulte a continuación para obtener un ejemplo detallado

Como se mencionó en [este comentario](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), hay otras bibliotecas que esperan secretos codificados en base64 (bytes aleatorios codificados mediante base64), si es el caso, puede pasar `Buffer.from(secret, 'base64')`. Al hacerlo, el secreto se descodificará mediante base64 y la comprobación del token usará los bytes aleatorios originales.

`options`

* `algorithms`: Lista de cadenas con los nombres de los algoritmos permitidos. Por ejemplo, `["HS256", "HS384"]`.
* `audience`: si desea comprobar la audiencia (`aud`), proporcione un valor aquí. La audiencia se puede comprobar con una cadena, una expresión regular o una lista de cadenas o expresiones regulares. 
  > Por ejemplo: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`
* `complete`: devuelve un objeto con el `{ payload, header, signature }` descodificado en lugar de solo el contenido habitual de la carga.
* `issuer` (opcional): cadena o matriz de cadenas de valores válidos para el campo `iss`.
* `ignoreExpiration`: si `true` no valida la expiración del token.
* `ignoreNotBefore`...
* `subject`: si desea comprobar el firmante (`sub`), proporcione un valor aquí
* `clockTolerance`: número de segundos que se tolerarán al comprobar las notificaciones `nbf` y `exp` para tratar pequeñas diferencias de reloj entre distintos servidores
* `maxAge`: la antigüedad máxima permitida para que los tokens sigan siendo válidos. Se expresa en segundos o una cadena que describe un intervalo de tiempo [zeit/ms](https://github.com/zeit/ms). 
  > Por ejemplo: `1000`, `"2 days"`, `"10h"`, `"7d"`. Un valor numérico se interpreta como un recuento de segundos. Si usa una cadena, asegúrese de proporcionar las unidades de tiempo (días, horas, etc.), de lo contrario, se usa la unidad de milisegundos de forma predeterminada (`"120"` es igual a `"120ms"`).
* `clockTimestamp`: tiempo en segundos que se debe usar como hora actual para todas las comparaciones necesarias.
* `nonce`: si desea comprobar la notificación `nonce`, proporcione un valor de cadena aquí. Se usa en Open ID para los tokens de identificador. ([Notas de implementación de Open ID](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes))


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Sincrónica) Devuelve la carga descodificada sin comprobar si la firma es válida.

> __Advertencia:__ Esto __no__ comprobará si la firma es válida. __No__ debe usarlo para mensajes que no son de confianza. Lo más probable es que quiera usar `jwt.verify` en su lugar.

`token` es la cadena JsonWebToken

`options`:

* `json`: fuerza JSON.parse en la carga incluso si el encabezado no contiene `"typ":"JWT"`.
* `complete`: devuelve un objeto con la carga y el encabezado descodificados.

Ejemplo

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Errores & códigos
Posibles errores producidos durante la comprobación.
El error es el primer argumento de la devolución de llamada de comprobación.

### <a name="tokenexpirederror"></a>TokenExpiredError

Se produce un error si el token ha expirado.

Objeto de error:

* name: 'TokenExpiredError'
* mensaje: 'jwt expirado'
* expirado el: [Fecha de exp]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Objeto de error:

* name: 'JsonWebTokenError'
* correspondiente:
  * 'jwt con formato incorrecto'
  * 'se requiere la firma jwt'
  * 'firma no válida'
  * 'audiencia jwt no válida. esperado: [OPCIONES DE AUDIENCIA]'
  * 'emisor de jwt no válido. esperado: [OPCIONES DE EMISOR]'
  * 'id de jwt no válido. esperado: [OPCIONES DE ID DE JWT]'
  * 'firmante de jwt no válido. esperado: [OPCIONES DE FIRMANTE]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Se produce si la hora actual es anterior a la notificación nbf.

Objeto de error:

* name: 'NotBeforeError'
* mensaje: 'jwt no activo'
* date: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Algoritmos admitidos

Matriz de algoritmos admitidos. Actualmente se admiten los siguientes algoritmos.

Valor de parámetro alg | Firma digital o algoritmo MAC
----------------|----------------------------
HS256 | HMAC mediante el algoritmo hash SHA-256
HS384 | HMAC mediante el algoritmo hash SHA-384
HS512 | HMAC mediante el algoritmo hash SHA-512
RS256 | RSASSA-PKCS1-v1_5 mediante el algoritmo hash SHA-256
RS384 | RSASSA-PKCS1-v1_5 mediante el algoritmo hash SHA-384
RS512 | RSASSA-PKCS1-v1_5 mediante el algoritmo hash SHA-512
PS256 | RSASSA-PSS mediante el algoritmo hash SHA-256 (solo el nodo ^6.12.0 O >=8.0.0)
PS384 | RSASSA-PSS mediante el algoritmo hash SHA-384 (solo el nodo ^6.12.0 O >=8.0.0)
PS512 | RSASSA-PSS mediante el algoritmo hash SHA-512 (solo el nodo ^6.12.0 O >=8.0.0)
ES256 | ECDSA mediante la curva P-256 y el algoritmo hash SHA-256
ES384 | ECDSA mediante la curva P-384 y el algoritmo hash SHA-384
ES512 | ECDSA mediante la curva P-521 y el algoritmo hash SHA-512
ninguno | No se incluye ninguna firma digital ni valor MAC

## <a name="refreshing-jwts"></a>Actualizar JWT

En primer lugar, le recomendamos que piense detenidamente si la actualización automática de un JWT no presentará ninguna vulnerabilidad en el sistema.

No nos sentimos cómodos al incluir esto como parte de la biblioteca, pero puede echar un vistazo a [este ejemplo](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) para mostrar cómo se puede lograr.
Aparte de ese ejemplo hay [un problema](https://github.com/auth0/node-jsonwebtoken/issues/122) y [una solicitud de incorporación de cambios](https://github.com/auth0/node-jsonwebtoken/pull/172) para obtener más información sobre este tema.

# <a name="todo"></a>TODO

* La cadena de certificados X.509 no es válida

## <a name="issue-reporting"></a> Notificación de problemas 

Si ha encontrado un error o si tiene una solicitud de característica, notifíquelos en esta sección de problemas del repositorio. No informe de vulnerabilidades de seguridad en el seguimiento público de GitHub. El [Programa de divulgación responsable](https://auth0.com/whitehat) detalla el procedimiento para revelar problemas de seguridad.

## <a name="author"></a>Autor

[Auth0](https://auth0.com)

## <a name="license"></a>Licencia

Este proyecto se publica con la licencia MIT. Consulte el archivo [LICENSE](LICENSE) para obtener más información.
