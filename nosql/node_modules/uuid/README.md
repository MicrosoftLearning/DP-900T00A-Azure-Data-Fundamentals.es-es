---
ms.openlocfilehash: c6dc9b216d8255c51f2dc575a7c59dce25deff9e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052054"
---
<!--
  -- This file is auto-generated from README_js.md. Changes should be made there.
  -->

# <a name="uuid-cihttpsgithubcomuuidjsuuidactionsqueryworkflow3aci-browserhttpsgithubcomuuidjsuuidactionsqueryworkflow3abrowser"></a>uuid [![CI](https://github.com/uuidjs/uuid/workflows/CI/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ACI) [![Explorador](https://github.com/uuidjs/uuid/workflows/Browser/badge.svg)](https://github.com/uuidjs/uuid/actions?query=workflow%3ABrowser)

Para la creación de UUID de [RFC4122](http://www.ietf.org/rfc/rfc4122.txt)

- **Completo**: compatibilidad con UUID de RFC4122 versión 1, 3, 4 y 5
- **Multiplataforma**: compatibilidad con...
  - CommonJS, [módulos ECMAScript](#ecmascript-modules) y [compilaciones de CDN](#cdn-builds)
  - Nodo 8, 10, 12, 14
  - Navegadores Chrome, Safari, Firefox, Edge, IE 11
  - Conjunto de módulos de webpack y rollup.js
  - [React Native/Expo](#react-native--expo)
- **Seguro**: valores aleatorios seguros de forma criptográfica
- **Pequeño**: cero dependencia, superficie de memoria pequeña, se reproduce bien con paquetes "sacudida de árboles"
- **CLI**: incluye la utilidad [línea de comandos `uuid`](#command-line)

**¿Actualizando desde `uuid@3.x`?** Es probable que el código esté bien, pero consulte [Actualización desde `uuid@3.x`](#upgrading-from-uuid3x) para obtener más información.

## <a name="quickstart"></a>Inicio rápido

Para crear un UUID aleatorio...

**1. Instale**

```shell
npm install uuid
```

**2. Cree un UUID** (sintaxis del módulo ES6)

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d'
```

... o mediante la sintaxis de CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

En el caso de UUID de marca de tiempo, UUID de espacio de nombres y otras opciones leídas en ...

## <a name="api-summary"></a>Resumen de la API

|  |  |  |
| --- | --- | --- |
| [`uuid.NIL`](#uuidnil) | La cadena UUID nula (todo ceros) | Novedad en `uuid@8.3` |
| [`uuid.parse()`](#uuidparsestr) | Convierte la cadena UUID en una matriz de bytes | Novedad en `uuid@8.3` |
| [`uuid.stringify()`](#uuidstringifyarr-offset) | Convierte la matriz de bytes en una cadena UUID | Novedad en `uuid@8.3` |
| [`uuid.v1()`](#uuidv1options-buffer-offset) | Crea un UUID de versión 1 (marca de tiempo) |  |
| [`uuid.v3()`](#uuidv3name-namespace-buffer-offset) | Crea un UUID de versión 3 (espacio de nombres con MD5) |  |
| [`uuid.v4()`](#uuidv4options-buffer-offset) | Crea un UUID de versión 4 (aleatoria) |  |
| [`uuid.v5()`](#uuidv5name-namespace-buffer-offset) | Crea un UUID de versión 5 (espacio de nombres con SHA-1) |  |
| [`uuid.validate()`](#uuidvalidatestr) | Prueba de una cadena para ver si es un UUID válido | Novedad en `uuid@8.3` |
| [`uuid.version()`](#uuidversionstr) | Detecta la versión RFC de un UUID | Novedad en `uuid@8.3` |

## <a name="api"></a>API

### <a name="uuidnil"></a>uuid.NIL

La cadena UUID nula (todo ceros).

Ejemplo:

```javascript
import { NIL as NIL_UUID } from 'uuid';

NIL_UUID; // ⇨ '00000000-0000-0000-0000-000000000000'
```

### <a name="uuidparsestr"></a>uuid.parse(str)

Convierte la cadena UUID en una matriz de bytes

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | `String` de UUID no válida                    |
| _returns_ | `Uint8Array[16]`                         |
| _throws_  | `TypeError` si `str` no es un UUID válido |

Nota: el orden de valores en las matrices de bytes usadas por `parse()` y `stringify()` sigue el orden derecha &Rarr; izquierda de los pares hexadecimales en cadenas UUID. Como se muestra en el ejemplo siguiente.

Ejemplo:

```javascript
import { parse as uuidParse } from 'uuid';

// Parse a UUID
const bytes = uuidParse('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b');

// Convert to hex strings to show byte order (for documentation purposes)
[...bytes].map((v) => v.toString(16).padStart(2, '0')); // ⇨ 
  // [
  //   '6e', 'c0', 'bd', '7f',
  //   '11', 'c0', '43', 'da',
  //   '97', '5e', '2a', '8a',
  //   'd9', 'eb', 'ae', '0b'
  // ]
```

### <a name="uuidstringifyarr-offset"></a>uuid.stringify(arr[, offset])

Convierte la matriz de bytes en una cadena UUID

|                |                                                                              |
| -------------- | ---------------------------------------------------------------------------- |
| `arr`          | Colección de 16 valores (a partir de `offset`) entre 0 y 255 de tipo `Array`. |
| [`offset` = 0] | Índice que comienza por `Number` en la matriz                                         |
| _returns_      | `String`                                                                     |
| _throws_       | `TypeError` si no se puede generar una cadena UUID válida                       |

Nota: el orden de valores en las matrices de bytes usadas por `parse()` y `stringify()` sigue el orden derecha &Rarr; izquierda de los pares hexadecimales en cadenas UUID. Como se muestra en el ejemplo siguiente.

Ejemplo:

```javascript
import { stringify as uuidStringify } from 'uuid';

const uuidBytes = [
  0x6e,
  0xc0,
  0xbd,
  0x7f,
  0x11,
  0xc0,
  0x43,
  0xda,
  0x97,
  0x5e,
  0x2a,
  0x8a,
  0xd9,
  0xeb,
  0xae,
  0x0b,
];

uuidStringify(uuidBytes); // ⇨ '6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'
```

### <a name="uuidv1options-buffer-offset"></a>uuid.v1([options[, buffer[, offset]]])

Crea un UUID de RFC de versión 1 (marca de tiempo)

|  |  |
| --- | --- |
| [`options`] | `Object` con una o varias de las siguientes propiedades: |
| [`options.node` ] | Campo RFC "node" como `Array[6]` de valores de bytes (por 4.1.6) |
| [`options.clockseq`] | RFC "clock sequence" como `Number` entre 0 y 0x3fff |
| [`options.msecs`] | Campo RFC "timestamp" (`Number` de milisegundos, época unix) |
| [`options.nsecs`] | Campo RFC "timestamp" (`Number` de nanosegundos que se van a agregar a `msecs`, debe ser de 0 a 10 000) |
| [`options.random`] | `Array` de 16 bytes aleatorios (0-255) |
| [`options.rng`] | Alternativa a `options.random`, `Function` que devuelve un valor `Array` de 16 bytes aleatorios (0-255) |
| [`buffer`] | Si se especifica `Array \| Buffer`, uuid se escribirá aquí en formato byte, empezando por `offset` |
| [`offset` = 0] | Índice de `Number` para empezar a escribir bytes UUID en `buffer` |
| _returns_ | `String` de UUID si no se especifica ningún valor `buffer`; de lo contrario, devuelve `buffer` |
| _throws_ | `Error` si se solicitan más de 10 M de UUID por segundo |

Nota: el [identificador de nodo](https://tools.ietf.org/html/rfc4122#section-4.1.6) predeterminado (los últimos 12 dígitos del UUID) se genera una vez, aleatoriamente, en el inicio del proceso y, después, permanece sin cambios durante la duración del proceso.

Nota: `options.random` y `options.rng` solo son significativos en la primera llamada a `v1()`, donde se pueden pasar para inicializar los campos internos `node` y `clockseq`.

Ejemplo:

```javascript
import { v1 as uuidv1 } from 'uuid';

uuidv1(); // ⇨ '2c5ea4c0-4067-11e9-8bad-9b1deb4d3b7d'
```

Ejemplo con `options`:

```javascript
import { v1 as uuidv1 } from 'uuid';

const v1options = {
  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],
  clockseq: 0x1234,
  msecs: new Date('2011-11-01').getTime(),
  nsecs: 5678,
};
uuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'
```

### <a name="uuidv3name-namespace-buffer-offset"></a>uuid.v3(name, namespace[, buffer[, offset]])

Crea un UUID de RFC de versión 3 (espacio de nombres con MD5)

La API es idéntica a `v5()`, pero usa "v3" en su lugar.

&#x26a0;&#xfe0f; Nota: por el RFC, "_si la compatibilidad con versiones anteriores supone un problema, se prefiere la [Version 5] de SHA-1_".

### <a name="uuidv4options-buffer-offset"></a>uuid.v4([options[, buffer[, offset]]])

Crea un UUID de RFC de versión 4 (aleatoria)

|  |  |
| --- | --- |
| [`options`] | `Object` con una o varias de las siguientes propiedades: |
| [`options.random`] | `Array` de 16 bytes aleatorios (0-255) |
| [`options.rng`] | Alternativa a `options.random`, `Function` que devuelve un valor `Array` de 16 bytes aleatorios (0-255) |
| [`buffer`] | Si se especifica `Array \| Buffer`, uuid se escribirá aquí en formato byte, empezando por `offset` |
| [`offset` = 0] | Índice de `Number` para empezar a escribir bytes UUID en `buffer` |
| _returns_ | `String` de UUID si no se especifica ningún valor `buffer`; de lo contrario, devuelve `buffer` |

Ejemplo:

```javascript
import { v4 as uuidv4 } from 'uuid';

uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Ejemplo de uso de valores `random` predefinidos:

```javascript
import { v4 as uuidv4 } from 'uuid';

const v4options = {
  random: [
    0x10,
    0x91,
    0x56,
    0xbe,
    0xc4,
    0xfb,
    0xc1,
    0xea,
    0x71,
    0xb4,
    0xef,
    0xe1,
    0x67,
    0x1c,
    0x58,
    0x36,
  ],
};
uuidv4(v4options); // ⇨ '109156be-c4fb-41ea-b1b4-efe1671c5836'
```

### <a name="uuidv5name-namespace-buffer-offset"></a>uuid.v5(name, namespace[, buffer[, offset]])

Crea un UUID de RFC de versión 5 (espacio de nombres con SHA-1)

|  |  |
| --- | --- |
| `name` | `String \| Array` |
| `namespace` | UUID del espacio de nombres `String \| Array[16]` |
| [`buffer`] | Si se especifica `Array \| Buffer`, uuid se escribirá aquí en formato byte, empezando por `offset` |
| [`offset` = 0] | Índice de `Number` para empezar a escribir bytes UUID en `buffer` |
| _returns_ | `String` de UUID si no se especifica ningún valor `buffer`; de lo contrario, devuelve `buffer` |

Nota: Los espacio de nombres de RFC `DNS` y `URL` están disponibles como `v5.DNS` y `v5.URL`.

Ejemplo con espacio de nombres personalizado:

```javascript
import { v5 as uuidv5 } from 'uuid';

// Define a custom namespace.  Readers, create your own using something like
// https://www.uuidgenerator.net/
const MY_NAMESPACE = '1b671a64-40d5-491e-99b0-da01ff1f3341';

uuidv5('Hello, World!', MY_NAMESPACE); // ⇨ '630eb68f-e0fa-5ecc-887a-7c7a62614681'
```

Ejemplo con espacio de nombres de RFC `URL`:

```javascript
import { v5 as uuidv5 } from 'uuid';

uuidv5('https://www.w3.org/', uuidv5.URL); // ⇨ 'c106a26a-21bb-5538-8bf2-57095d1976c1'
```

### <a name="uuidvalidatestr"></a>uuid.validate(str)

Prueba de una cadena para ver si es un UUID válido

|           |                                                     |
| --------- | --------------------------------------------------- |
| `str`     | `String` para validar                                |
| _returns_ | `true` si la cadena es un UUID válido; de lo contrario, `false` |

Ejemplo:

```javascript
import { validate as uuidValidate } from 'uuid';

uuidValidate('not a UUID'); // ⇨ false
uuidValidate('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ true
```

Al usar `validate` y `version` juntos, es posible realizar la validación por versión, por ejemplo, validar solo los UUId v4.

```javascript
import { version as uuidVersion } from 'uuid';
import { validate as uuidValidate } from 'uuid';

function uuidValidateV4(uuid) {
  return uuidValidate(uuid) && uuidVersion(uuid) === 4;
}

const v1Uuid = 'd9428888-122b-11e1-b85c-61cd3cbb3210';
const v4Uuid = '109156be-c4fb-41ea-b1b4-efe1671c5836';

uuidValidateV4(v4Uuid); // ⇨ true
uuidValidateV4(v1Uuid); // ⇨ false
```

### <a name="uuidversionstr"></a>uuid.version(str)

Detecta la versión RFC de un UUID

|           |                                          |
| --------- | ---------------------------------------- |
| `str`     | `String` de UUID no válida                    |
| _returns_ | `Number` La versión RFC del UUID     |
| _throws_  | `TypeError` si `str` no es un UUID válido |

Ejemplo:

```javascript
import { version as uuidVersion } from 'uuid';

uuidVersion('45637ec4-c85f-11ea-87d0-0242ac130003'); // ⇨ 1
uuidVersion('6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b'); // ⇨ 4
```

## <a name="command-line"></a>Línea de comandos

Los UUID se pueden generar desde la línea de comandos mediante `uuid`.

```shell
$ uuid
ddeb27fb-d9a0-4624-be4d-4615062daed4
```

El valor predeterminado es generar UUIDS de versión 4, pero se admiten las demás versiones. Escriba `uuid --help` para ver los detalles:

```shell
$ uuid --help

Usage:
  uuid
  uuid v1
  uuid v3 <name> <namespace uuid>
  uuid v4
  uuid v5 <name> <namespace uuid>
  uuid --help

Note: <namespace uuid> may be "URL" or "DNS" to use the corresponding UUIDs
defined by RFC4122
```

## <a name="ecmascript-modules"></a>Módulos ECMAScript

Esta biblioteca incluye compatibilidad con [módulos ECMAScript](https://www.ecma-international.org/ecma-262/6.0/#sec-modules) (ESM) para versiones Node.js que lo admiten ([ejemplo](./examples/node-esmodules/)), así como conjuntos como [rollup.js](https://rollupjs.org/guide/en/#tree-shaking) ([ejemplo](./examples/browser-rollup/)) y [webpack](https://webpack.js.org/guides/tree-shaking/) ([ejemplo](./examples/browser-webpack/)) (dirigidos tanto a entornos de Node.js como de explorador).

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
```

Para ejecutar los ejemplos, primero debe crear una compilación dist de esta biblioteca en la raíz del módulo:

```shell
npm run build
```

## <a name="cdn-builds"></a>Compilaciones de CDN

### <a name="ecmascript-modules"></a>Módulos ECMAScript

Para cargar este módulo directamente en exploradores modernos que [admiten la carga de módulos ECMAScript](https://caniuse.com/#feat=es6-module), puede usar [jspm](https://jspm.org/):

```html
<script type="module">
  import { v4 as uuidv4 } from 'https://jspm.dev/uuid';
  console.log(uuidv4()); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'
</script>
```

### <a name="umd"></a>UMD

Para cargar este módulo directamente en exploradores anteriores, puede usar las compilaciones [UMD (definición de módulo universal)](https://github.com/umdjs/umd) desde cualquiera de las siguientes redes CDN:

**Con [UNPKG](https://unpkg.com/uuid@latest/dist/umd/)** :

```html
<script src="https://unpkg.com/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Con [jsDelivr](https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/)** :

```html
<script src="https://cdn.jsdelivr.net/npm/uuid@latest/dist/umd/uuidv4.min.js"></script>
```

**Con [cdnjs](https://cdnjs.com/libraries/uuid)** :

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.1.0/uuidv4.min.js"></script>
```

Todas estas redes CDN proporcionan el mismo método [`uuidv4()`](#uuidv4options-buffer-offset):

```html
<script>
  uuidv4(); // ⇨ '55af1e37-0734-46d8-b070-a1e42e4fc392'
</script>
```

Los métodos para los demás algoritmos ([`uuidv1()`](#uuidv1options-buffer-offset), [`uuidv3()`](#uuidv3name-namespace-buffer-offset) y [`uuidv5()`](#uuidv5name-namespace-buffer-offset)) están disponibles en los archivos `uuidv1.min.js`, `uuidv3.min.js` y `uuidv5.min.js` respectivamente.

## <a name="getrandomvalues-not-supported"></a>"getRandomValues() not supported"

Este error se produce en entornos en los que no se admite la API estándar [`crypto.getRandomValues()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues). Este problema se puede resolver agregando un polyfill adecuado:

### <a name="react-native--expo"></a>React Native/Expo

1. Instale [`react-native-get-random-values`](https://github.com/LinusU/react-native-get-random-values#readme)
1. Impórtelo _antes_ de `uuid`. Como `uuid` también puede aparecer como una dependencia transitiva de otras importaciones, es más seguro simplemente importar `react-native-get-random-values` como lo primero en el punto de entrada:

```javascript
import 'react-native-get-random-values';
import { v4 as uuidv4 } from 'uuid';
```

Nota: si usa Expo, debe usar al menos `react-native-get-random-values@1.5.0` y `expo@39.0.0`.

### <a name="web-workers--service-workers-edge--18"></a>Rol de trabajo/Trabajos de servicio (Edge <= 18)

[En Edge <= 18, Web Crypto no se admite en rol de trabajo o trabajo de servicio](https://caniuse.com/#feat=cryptography) y no conocemos ningún polyfill (háganoslo saber si encuentra uno, por favor).

## <a name="upgrading-from-uuid7x"></a>Actualización desde `uuid@7.x`

### <a name="only-named-exports-supported-when-using-with-nodejs-esm"></a>Admisión de solo exportaciones con nombre al usarlo con ESM de Node.js

`uuid@7.x` no tenía compatibilidad nativa con el módulo ECMAScript (ESM) para Node.js. Al importarlo en ESM de Node.js se importó el origen de CommonJS con una exportación predeterminada. Esta biblioteca ahora incluye verdadera compatibilidad con ESM de Node.js y solo proporciona exportaciones con nombre.

En lugar de hacer esto:

```javascript
import uuid from 'uuid';
uuid.v4();
```

ahora tendrá que usar las exportaciones con nombre:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

### <a name="deep-requires-no-longer-supported"></a>Cese de soporte de solicitudes profundas

Las solicitudes profundas como `require('uuid/v4')` [que han quedado en desuso en `uuid@7.x`](#deep-requires-now-deprecated) ya no se admiten.

## <a name="upgrading-from-uuid3x"></a>Actualización desde `uuid@3.x`

" _¿Qué ha ocurrido con `uuid@4.x` - `uuid@6.x`?_ "

Para evitar confusiones con los UUID de RFC [versión 4](#uuidv4options-buffer-offset) y [5](#uuidv5name-namespace-buffer-offset), y una posible [versión 6](http://gh.peabody.io/uuidv6/), se han omitido las versiones 4 a 6 de este módulo.

### <a name="deep-requires-now-deprecated"></a>Solicitudes profundas ahora en desuso

`uuid@3.x` recomienda el uso de solicitudes profundas para minimizar el tamaño de lote de las compilaciones del explorador:

```javascript
const uuidv4 = require('uuid/v4'); // <== NOW DEPRECATED!
uuidv4();
```

A partir de `uuid@7.x`, esta biblioteca proporciona compilaciones de módulos ECMAScript, que permiten a los empaquetadores como Webpack y Rollup realizar "sacudida de árboles" para quitar el código no alcanzado. En su lugar, use la sintaxis `import`:

```javascript
import { v4 as uuidv4 } from 'uuid';
uuidv4();
```

... o para CommonJS:

```javascript
const { v4: uuidv4 } = require('uuid');
uuidv4();
```

### <a name="default-export-removed"></a>Exportación predeterminada quitada

`uuid@3.x` exportaba el método UUID de la versión 4 como exportación predeterminada:

```javascript
const uuid = require('uuid'); // <== REMOVED!
```

Este patrón de uso ya se desaconseja en `uuid@3.x` y se ha quitado en `uuid@7.x`.

----
Markdown generado a partir de [README_js.md](README_js.md) por [![el logotipo de RunMD](http://i.imgur.com/h0FVyzU.png)](https://github.com/broofa/runmd)