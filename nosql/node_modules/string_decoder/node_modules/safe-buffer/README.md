---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052133"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![descargas][downloads-image]][downloads-url] [![guía de estilo de javascript][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>API de búfer de Node.js más segura

**Use las nuevas API de búfer de Node.js (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) en todas las versiones de Node.js.**

**Usa la implementación integrada cuando está disponible.**

## <a name="install"></a>instalar

```
npm install safe-buffer
```

## <a name="usage"></a>usage

El objetivo de este paquete es proporcionar un reemplazo seguro para el node.js `Buffer`.

Es un reemplazo de drop-in para `Buffer`. Puede usarlo agregando una línea `require`a la parte superior de los módulos de node.js:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Método de clase: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Asigna un nuevo `Buffer` mediante un `array` de octetos.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

Se producirá un `TypeError` si `array` no es `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Método de clase: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} La `.buffer` propiedad de un `TypedArray` o un `new ArrayBuffer()`
* `byteOffset` {Number} Predeterminado: `0`
* `length` {Number} Predeterminado: `arrayBuffer.length - byteOffset`

Cuando se pasa una referencia a la propiedad `.buffer` de una instancia `TypedArray`, el recién creado `Buffer` compartirá la misma memoria asignada que TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Los argumentos opcionales `byteOffset` y `length` especifican un intervalo de memoria dentro del `arrayBuffer` que compartirá `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

Se producirá un `TypeError` si `arrayBuffer` no es `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Método de clase: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Copia los datos pasados `buffer` en una nueva instancia `Buffer`.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

Se producirá un `TypeError` si `buffer` no es `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Método de clase: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} Cadena que se va a modificar.
* `encoding` {String} Codificación que se va a usar, valor predeterminado: `'utf8'`

Crea un nuevo `Buffer` que contiene la cadena `str`de JavaScript especificada. Si se proporciona, el parámetro `encoding` identifica la codificación de caracteres.
Si no se proporciona, el valor predeterminado es `encoding` será `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

Se producirá un `TypeError` si `str` no es una cadena.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Método de clase: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} Predeterminado: `undefined`
* `encoding` {String} Predeterminado: `utf8`

Asigna un nuevo `Buffer` de `size` bytes. Si `fill` es `undefined`, `Buffer` se *rellenará con cero*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` debe ser menor o igual que el valor de `require('buffer').kMaxLength` (en arquitecturas de 64 bits, `kMaxLength` es `(2^31)-1`). De lo contrario, se produce [`RangeError`][]. Se creará un búfer de longitud cero si se especifica un `size` menor o igual que 0.

Si `fill` se especifica, la asignación de `Buffer` se inicializará llamando a `buf.fill(fill)`. Consulte [`buf.fill()`][] para obtener más información.

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Si `fill` y `encoding` se especifican, la asignación de `Buffer` se inicializará llamando a `buf.fill(fill, encoding)`. Por ejemplo:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

La llamada a `Buffer.alloc(size)` puede ser significativamente más lenta que la alternativa `Buffer.allocUnsafe(size)`, pero garantiza que el contenido de la instancia recién creada `Buffer`*nunca contendrá datos confidenciales*.

Se producirá un `TypeError` si `size` no es un número.

### <a name="class-method-bufferallocunsafesize"></a>Método de clase: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Asigna un nuevo relleno distinto de *cero* `Buffer` de `size` bytes.  `size` debe ser menor o igual que el valor de `require('buffer').kMaxLength` (en arquitecturas de 64 bits, `kMaxLength` es `(2^31)-1`). De lo contrario, se produce [`RangeError`][]. Se creará un búfer de longitud cero si se especifica un `size` menor o igual que 0.

La memoria subyacente de `Buffer` instancias creadas de esta manera *no se inicializa*. El contenido de la recién creada `Buffer` es desconocido y *puede contener datos confidenciales*. Use [`buf.fill(0)`][] para inicializar estas `Buffer` instancias en ceros.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Se producirá un `TypeError` si `size` no es un número.

Tenga en cuenta que el módulo `Buffer` asigna previamente una instancia interna `Buffer` de tamaño `Buffer.poolSize` que se usa como grupo para la asignación rápida de nuevas `Buffer` instancias creadas mediante `Buffer.allocUnsafe(size)` (y el constructor en desuso `new Buffer(size)`) solo cuando `size` es menor o igual `Buffer.poolSize >> 1` que (planta de `Buffer.poolSize` dividida por dos). El valor predeterminado de `Buffer.poolSize` es `8192` pero se puede modificar.

El uso de este grupo de memoria interno asignado previamente es una diferencia clave entre llamar a `Buffer.alloc(size, fill)` y llamar a `Buffer.allocUnsafe(size).fill(fill)`. En concreto, `Buffer.alloc(size, fill)` *nunca* usará el grupo de búferes interno, mientras que `Buffer.allocUnsafe(size).fill(fill)` *usará* el grupo de búferes interno si `size` es menor o igual que la mitad `Buffer.poolSize`. La diferencia es sutil, pero puede ser importante cuando una aplicación requiere el rendimiento adicional que `Buffer.allocUnsafe(size)` proporciona.

### <a name="class-method-bufferallocunsafeslowsize"></a>Método de clase: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Asigna un nuevo elemento *relleno distinto de cero* y no agrupado `Buffer` de `size` bytes.  `size` debe ser menor o igual que el valor de `require('buffer').kMaxLength` (en arquitecturas de 64 bits, `kMaxLength` es `(2^31)-1`). De lo contrario, se produce [`RangeError`][]. Se creará un búfer de longitud cero si se especifica un `size` menor o igual que 0.

La memoria subyacente de `Buffer` instancias creadas de esta manera *no se inicializa*. El contenido de la recién creada `Buffer` es desconocido y *puede contener datos confidenciales*. Use [`buf.fill(0)`][] para inicializar estas `Buffer` instancias en ceros.

Cuando se usa `Buffer.allocUnsafe()` para asignar nuevas instancias `Buffer`, las asignaciones inferiores a 4 KB se segmentan de forma predeterminada a partir de una única `Buffer` asignada previamente. Esto permite a las aplicaciones evitar la sobrecarga de recolección de elementos no utilizados de la creación de muchos búferes asignados individualmente. Este enfoque mejora tanto el rendimiento como el uso de memoria al eliminar la necesidad de realizar un seguimiento y limpiar tantos objetos `Persistent`.

Sin embargo, en el caso de que un desarrollador necesite conservar un pequeño fragmento de memoria de un grupo durante un período de tiempo indeterminado, puede ser adecuado crear una instancia de búfer no agrupada mediante `Buffer.allocUnsafeSlow()`, a continuación, copiar los bits pertinentes.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

El uso de `Buffer.allocUnsafeSlow()` solo debe usarse como último recurso *después de*  que un desarrollador haya observado una retención de memoria innecesaria en sus aplicaciones.

Se producirá un `TypeError` si `size` no es un número.

### <a name="all-the-rest"></a>Todo el resto

El resto de la API `Buffer` es exactamente igual que en node.js.
[Consultar los documentos](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Vínculos relacionados

- [Incidencia de Node.js: (número) de búfer no es seguro](https://github.com/nodejs/node/issues/4660)
- [Propuesta de mejora de Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>¿Por qué `Buffer` no es seguro?

En la actualidad, el constructor de node.js `Buffer` se sobrecarga para controlar muchos tipos de argumentos diferentes como `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, etc.), `ArrayBuffer`y también `Number`.

La API está optimizada para mayor comodidad: puede iniciar cualquier tipo en ella y intentará hacer lo que quiera.

Dado que el constructor de búfer es tan eficaz, a menudo se ve código similar al siguiente:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***¿Pero qué ocurre si `toHex` se llama con un argumento`Number`?***

### <a name="remote-memory-disclosure"></a>Divulgación de memoria remota

Si un atacante puede hacer que el programa llame al `Buffer` constructor con un argumento `Number`, puede hacer que asigne memoria no inicializada desde el proceso de node.js.
Esto podría revelar potencialmente claves privadas TLS, datos de usuario o contraseñas de base de datos.

Cuando se pasa un `Buffer` argumento al `Number` constructor, devuelve un bloque **UNINITIALIZED** de memoria del `size` especificado. Al crear un `Buffer` similar a este, **DEBE** sobrescribir el contenido antes de devolverlo al usuario.

En los [ documentos de node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - `size` Número
>
> La memoria subyacente de `Buffer` instancias creadas de esta manera no se inicializa.
> **El contenido de la recién creada `Buffer` es desconocido y puede contener datos confidenciales.** Use `buf.fill(0)` para inicializar un búfer en ceros.

(Énfasis en el nuestro.)

Siempre que el programador pretende crear un elemento sin inicializar `Buffer`, a menudo verá código similar al siguiente:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>¿Podría ser un problema en el código real?

Sí. Es sorprendentemente habitual olvidarse de comprobar el tipo de las variables en un lenguaje con tipo dinámico, como JavaScript.

Normalmente, las consecuencias de asumir el tipo incorrecto es que el programa se bloquea con una excepción no detectada. Pero el modo de error para olvidar comprobar el tipo de argumentos para el constructor `Buffer` es más catastrófico.

Este es un ejemplo de un servicio vulnerable que toma una carga JSON y la convierte en hexadecimal:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

En este ejemplo, un cliente http solo tiene que enviar:

```json
{
  "str": 1000
}
```

y recuperará 1000 bytes de memoria no inicializada del servidor.

Este es un error muy serio. Es similar en gravedad al [error Heartbleed](http://heartbleed.com/) que permitió la divulgación de la memoria del proceso de OpenSSL por parte de atacantes remotos.


### <a name="which-real-world-packages-were-vulnerable"></a>¿Qué paquetes reales eran vulnerables?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) y I ([Feross Aboukhadijeh](http://feross.org/)) encontraron este problema en uno de nuestros propios paquetes, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). El error permitiría a cualquier persona de Internet enviar una serie de mensajes a un usuario de `bittorrent-dht` y obtenerlos para revelar 20 bytes en un momento de memoria sin inicializar desde el proceso de node.js.

Esta es [la confirmación](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) que la corrigió. Hemos publicado una nueva versión fija, hemos creado una [divulgación del proyecto de seguridad de Node](https://nodesecurity.io/advisories/68) y hemos dejado de usar todas las versiones vulnerables en npm para que los usuarios obtengan una advertencia para actualizar a una versión más reciente.

#### [`ws`](https://www.npmjs.com/package/ws)

Eso nos hizo preguntarnos si había otros paquetes vulnerables. En un breve período de tiempo, encontramos el mismo problema en [`ws`](https://www.npmjs.com/package/ws), la implementación de WebSocket más popular en node.js.

Si se llamaba a determinadas API con parámetros `Number` en lugar de `String` o `Buffer` según lo esperado, la memoria del servidor sin inicializar se divulgaría al nodo del mismo nivel remoto.

Estos eran los métodos vulnerables:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Este es un servidor de socket vulnerable con alguna funcionalidad de eco:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

`socket.send(number)` llamado en el servidor, revelará la memoria del servidor.

Esta es [la versión en la](https://github.com/websockets/ws/releases/tag/1.0.1) que se corrigió el problema, con una explicación más detallada. Enhorabuena a [Arnout Kazemier](https://github.com/3rd-Eden) por la rápida solución. Esta es la [divulgación del proyecto de seguridad de nodo](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>¿Cuál es la solución?

Es importante que node.js ofrezca una manera rápida de obtener memoria; de lo contrario, las aplicaciones críticas para el rendimiento no necesitarían obtener mucho más lento.

Pero necesitamos una mejor manera de *señalar nuestra intención* como programadores. **Cuando queremos memoria sin inicializar, debemos solicitarla explícitamente.**

La funcionalidad confidencial no debe empaquetarse en una API fácil de usar para desarrolladores que acepte de forma flexible muchos tipos diferentes. Este tipo de API fomenta la práctica diferida de pasar variables sin comprobar el tipo con mucho cuidado.

#### <a name="a-new-api-bufferallocunsafenumber"></a>La nueva API: `Buffer.allocUnsafe(number)`

La funcionalidad de crear búferes con memoria no inicializada debe formar parte de otra API. Propondremos `Buffer.allocUnsafe(number)`. De este modo, no forma parte de una API que con frecuencia obtiene la entrada del usuario de todo tipo de tipos diferentes que se le pasan.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>¿Cómo se corrige el núcleo de node.js?

Hemos enviado [una solicitud de incorporación de cambios en el núcleo de node.js ](https://github.com/nodejs/node/pull/4514) (combinada como `semver-major`) que defiende un caso:

```js
var str = 16
new Buffer(str, 'utf8')
```

En esta situación, se supone que el programador pretendía que el primer argumento fuera una cadena, ya que pasaron una codificación como segundo argumento. En la actualidad, node.js asignará memoria no inicializada en el caso de `new Buffer(number, encoding)`, que probablemente no sea lo que el programador pretendía.

Pero esto es solo una solución parcial, ya que si el programador hace `new Buffer(variable)` (sin un parámetro `encoding`) no hay ninguna manera de saber lo que pretende. Si `variable` a veces es un número, a veces se devolverá memoria sin inicializar.

### <a name="whats-the-real-long-term-fix"></a>¿Cuál es la corrección a largo plazo real?

Podríamos dejar en desuso y quitar `new Buffer(number)` y usar `Buffer.allocUnsafe(number)` cuando necesitamos memoria sin inicializar. Pero eso interrumpiría 1000 paquetes.

~~Creemos que la mejor solución es:~~

~~1. Cambiar `new Buffer(number)` para devolver memoria segura y sin cero~~

~~2. Crear una nueva API para crear búferes sin inicializar. Proponemos `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Actualizar

Ahora se admite la adición de tres nuevas API:

- `Buffer.from(value)`: convierte de cualquier tipo a un búfer
- `Buffer.alloc(size)`: crea un búfer de relleno cero
- `Buffer.allocUnsafe(size)`: crea un búfer sin inicializar con un tamaño determinado

Esto resuelve el problema principal que afectaba a `ws` y `bittorrent-dht`, que consiste en engañar a `Buffer(variable)` para tomar un argumento numérico.

De este modo, el código existente sigue funcionando y el impacto en el ecosistema de npm será mínimo. Con el tiempo, los mantenedores de npm pueden migrar código crítico para el rendimiento para usar `Buffer.allocUnsafe(number)` en lugar de `new Buffer(number)`.


### <a name="conclusion"></a>Conclusión

Creemos que hay un problema de diseño serio con la API `Buffer` tal y como existe hoy. Promueve el software no seguro colocando una funcionalidad de alto riesgo en una API cómoda con una "ergonómica para desarrolladores".

Esto no era simplemente un ejercicio teórico porque encontramos el problema en algunos de los paquetes de npm más populares.

Afortunadamente, hay una solución fácil que se puede aplicar hoy en día. Utilizar `safe-buffer` en lugar de `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

Finalmente, esperamos que el núcleo de node.js pueda cambiar a este nuevo comportamiento más seguro. Creemos que el impacto en el ecosistema sería mínimo, ya que no es un cambio importante.
Bien mantenidos, los paquetes populares se actualizarían para usar `Buffer.alloc` rápidamente, mientras que los paquetes más antiguos y no seguros quedarían protegidos frente a este vector de ataque.


## <a name="links"></a>vínculos

- [Node.js PR: búfer: se produce si se pasan tanto length como enc](https://github.com/nodejs/node/pull/4514)
- [Divulgación del proyecto de seguridad de Node para `ws`](https://nodesecurity.io/advisories/67)
- [Divulgación del proyecto de seguridad de Node para `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>crédito

Los problemas originales en `bittorrent-dht` ([divulgación](https://nodesecurity.io/advisories/68)) y `ws` ([divulgación](https://nodesecurity.io/advisories/67)) fueron [descubiertos por Mathias Buus](https://github.com/mafintosh) y [Feross Aboukhadijeh](http://feross.org/).

Gracias a [Adam Baldwin](https://github.com/evilpacket) por ayudar a revelar estos problemas y por su trabajo ejecutando el [Proyecto de seguridad de Node](https://nodesecurity.io/).

Gracias a [John Hiesey](https://github.com/jhiesey) para revisar este ARCHIVO LÉAME y auditar el código.


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
