---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052334"
---
# <a name="combined-stream"></a>combined-stream

Secuencia que emite varias secuencias una después de otra.

**NB** Actualmente `combined-stream` solo funciona con secuencias de la versión 1. Se está trabajando en cambiar esta biblioteca a secuencias versión 2. Cualquier ayuda es bienvenida. :) Mientras tanto, puede explorar otras bibliotecas que funcionan con streams2, con más o menos compatibilidad con `combined-stream`.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2): Un reemplazo compatible con streams2 de drop-in para el módulo combined-stream.

- [multistream](https://www.npmjs.com/package/multistream): Secuencia que emite varias secuencias una después de otra.

## <a name="installation"></a>Instalación

``` bash
npm install combined-stream
```

## <a name="usage"></a>Uso

Este es un ejemplo sencillo que muestra cómo puede usar combined-stream para combinar dos archivos en uno:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Aunque el ejemplo anterior funciona bien, pausará todas las secuencias de origen hasta que sean necesarias. Si no desea que esto ocurra, entonces puede establecer `pauseStreams` en `false`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Sin embargo, ¿qué ocurre si aún no tiene todas las secuencias de origen o no quiere asignar los recursos (descriptores de archivo, memoria, etc.) inmediatamente?
En ese caso, simplemente puede proporcionar una devolución de llamada que proporcione la secuencia mediante una llamada a una función `next()`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Devuelve un nuevo objeto de secuencia combinado. Las opciones disponibles son la siguientes:

* `maxDataSize`
* `pauseStreams`

El efecto de estas opciones se describe a continuación.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Si se va a aplicar presión inversa a las secuencias subyacentes. Si se establece en `false`, las secuencias subyacentes nunca se pausarán. Si se establece en `true`, las secuencias subyacentes se pausarán justo después de anexarse, así como cuando `delayedStream.pipe()` se quiera limitar.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

Cantidad máxima de bytes (o caracteres) que se va a almacenar en búfer para todas las secuencias de origen.
Si se supera este valor, `combinedStream` emite un evento `'error'`.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

Cantidad de bytes (o caracteres) almacenados actualmente en búfer por `combinedStream`.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Anexa el objeto especificado `stream` al objeto combinedStream. Si `pauseStreams` se establece en "true", esta secuencia también se pausará inmediatamente.

`streams` también puede ser una función que toma un parámetro denominado `next`. `next` es una función que se debe invocar para proporcionar la secuencia `next`, consulte el ejemplo anterior.

Independientemente de cómo se anexe `stream`, combined-stream siempre adjunta un agente de escucha `'error'`, por lo que no tendrá que hacerlo manualmente.

Caso especial: `stream` también puede ser una cadena o un búfer.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

No debe llamar a esto, `combinedStream` se encarga de canalizar los flujos anexados a sí mismo.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Hace que `combinedStream` empiece a purgar los flujos que administra. La función es idempotente y también emite un evento `'resume'` cada vez, que suele ir a la secuencia que se está purgando actualmente.

### <a name="combinedstreampause"></a>combinedStream.pause();

Si `combinedStream.pauseStreams` se establece en `false`, no hace nada.
De lo contrario, se emite un evento `'pause'`, que va a la secuencia que se está purgando actualmente, por lo que puede usarlo para aplicar presión inversa.

### <a name="combinedstreamend"></a>combinedStream.end();

Establece `combinedStream.writable` en false, emite un evento `'end'` y quita todas las secuencias de la cola.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

Igual que `combinedStream.end()`, excepto que emite un evento `'close'` en lugar de `'end'`.

## <a name="license"></a>Licencia

combined-stream se publica en virtud de la licencia de MIT.
