---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052214"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI — [![Estado de compilación](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) de JavaScript BigInts puro [![jsbi en npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI es una implementación pura de JavaScript de [la propuesta BigInt de ECMAScript](https://tc39.es/proposal-bigint/), que oficialmente se convirtió en parte del lenguaje JavaScript en ES2020.

## <a name="installation"></a>Instalación

```sh
npm install jsbi --save
```

## <a name="usage"></a>Uso

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Nota: llame explícitamente a `toString` en cualquier instancia `JSBI` cuando `console.log()`les haga ver su representación numérica (por ejemplo, `String(max)` o `max.toString()`). Sin él (por ejemplo `console.log(max)`), verá en su lugar el objeto que representa el valor.

Use [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) para transpilar el código JSBI en código BigInt nativo.

Consulte las instrucciones detalladas que se indican a continuación para obtener más información.

## <a name="why"></a>¿Por qué?

[Los BigInts nativos ya se envían](https://v8.dev/features/bigint) en exploradores modernos (en el momento de escribirlo, Google Chrome 67+, Opera 54+, Firefox 68+) y Node.js (v10.4+) y se espera que lleguen a otros exploradores en el futuro, lo que significa que aún no puede usarlos si desea que el código se ejecute en todas partes.

Para usar BigInts en el código de hoy, necesita una biblioteca. Pero hay una dificultad: la propuesta de BigInt cambia el comportamiento de los operadores (como `+`, `>=`, etc.) para trabajar en BigInts. En estos cambios no se puede realizar polyfill directamente y no es posible (en la mayoría de los casos) transpilar código BigInt para el código de reserva mediante Babel o herramientas similares. El motivo es que una transpilación de este tipo tendría que reemplazar a todos los operadores del programa por una llamada a alguna función que realice comprobaciones de tipos en sus entradas, lo que incurriría en una penalización de rendimiento inaceptable.

La solución consiste en hacerlo de la otra manera: escribir código mediante la sintaxis de una biblioteca y [transpilarlo al código BigInt nativo](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) cuando esté disponible. JSBI está diseñado exactamente para este propósito: proporciona una implementación BigInt "polyfill" que se comporta exactamente como la próxima BigInts nativa, pero con una sintaxis que se puede enviar en todos los exploradores hoy en día.

Sus ventajas sobre otras bibliotecas de enteros grandes existentes son:

- se comporta exactamente igual que BigInts nativo cuando están disponibles, por lo que para migrar, puede actualizar [mecánicamente](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) la sintaxis del código. No será necesario rediseñar su lógica.
- se centra en el rendimiento. En general, JSBI es competitivo con la implementación nativa que Google Chrome está enviando actualmente.

## <a name="how"></a>¿Cómo lo hago?

Excepto por las diferencias mecánicas en la sintaxis, use JSBI-BigInts [igual que usaría BigInts nativo](https://developers.google.com/web/updates/2018/05/bigint). Algunas cosas tienen incluso el mismo aspecto, tras reemplazar `BigInt` por `JSBI.BigInt`:

| Operación            | BigInts nativo          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Creación a partir de cadena | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Creación a partir del número | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Conversión a cadena | `a.toString(radix)`     | `a.toString(radix)`      |
| Conversión a número | `Number(a)`             | `JSBI.toNumber(a)`       |
| Truncamiento           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Comprobación de tipos           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

La mayoría de los operadores se reemplazan por llamadas de método:

| Operación                   | BigInts nativo | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Suma                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Resta                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Multiplicación              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| División                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Resto                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Exponenciación              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Negación                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Negación bit a bit            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Desplazamiento a la izquierda               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Desplazamiento a la derecha              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| Bit a bit “and”               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| Bit a bit “or”                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| Bit a bit “xor”               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Comparación con otros BigInts | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

Las funciones anteriores solo funcionan en BigInts. (No realizan comprobaciones de tipos en la implementación actual, ya que estas comprobaciones son una pérdida de tiempo cuando se supone que sabe lo que está haciendo. No intente llamarlos con otras entradas, ya que obtendrá errores "interesantes").

Algunas operaciones son especialmente interesantes cuando se proporcionan entradas de tipos mixtos, por ejemplo, la comparación de un BigInt con un número o la concatenación de una cadena con BigInt. Se implementan como funciones estáticas denominadas según los operadores nativos respectivos:

| Operación                       | BigInts nativo | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Comparación de igualdad abstracta    | `x == y`       | `JSBI.EQ(x, y)`  |
| Genérico "no igual"             | `x != y`       | `JSBI.NE(x, y)`  |
| Genérico "menor que"             | `x < y`        | `JSBI.LT(x, y)`  |
| Genérico: "inferior a o igual que"    | `x <= y`       | `JSBI.LE(x, y)`  |
| Genérico "mayor que"          | `x > y`        | `JSBI.GT(x, y)`  |
| Genérico: "superior a o igual que" | `x >= y`       | `JSBI.GE(x, y)`  |
| Adición genérica                | `x + y`        | `JSBI.ADD(x, y)` |

Los nombres de variable `x` y `y` aquí indican que las variables pueden hacer referencia a cualquier cosa, por ejemplo: `JSBI.GT(101.5, BigInt('100'))` o `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

Desafortunadamente, también hay algunas cosas que no se admiten en absoluto:

| Operación no admitida | BigInts nativo | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| literales              | `a = 123n;`    | N/A ☹                                |
| incremento             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| decremento             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

Es imposible replicar el comportamiento exacto de los operadores nativos `++` y `--` con funciones estáticas. Dado que JSBI está pensado para ser transpilado finalmente, no proporciona una alternativa similar pero diferente. Puede usar `JSBI.add()` y `JSBI.subtract()` en su lugar.

## <a name="when"></a>¿Cuándo?

¡Ahora! La biblioteca JSBI está lista para su uso en la actualidad.

Una vez que BigInts se admite de forma nativa en todas partes, use [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) para transpilar el código JSBI en código BigInt nativo de una vez.

Vea [nuestro seguimiento de problemas](https://github.com/GoogleChromeLabs/jsbi/issues) para obtener más información sobre nuestros planes para JSBI y únase a la conversación.

Un plan futuro menos definido consiste en usar la biblioteca JSBI (o una extensión) como base de ensayo para funcionalidades adicionales relacionadas con BigInt. La propuesta oficial es intencionadamente un poco mínima y deja las "funciones de biblioteca" adicionales para las propuestas de seguimiento. Algunos ejemplos son una función combinada `exp`+`mod` y funciones de manipulación de bits.

## <a name="development"></a>Desarrollo

1. Clone este repositorio y `cd` en el directorio local.

1. Use la versión de Node.js especificada en `.nvmrc`:

     ```sh
     nvm use
     ```

1. Instale dependencias de desarrollo:

    ```sh
    npm install
    ```

1. Ejecute las pruebas:

    ```sh
    npm test
    ```

    Consulte `npm run` para ver la lista de comandos.

## <a name="for-maintainers"></a>Para mantenedores

### <a name="how-to-publish-a-new-release"></a>Cómo publicar una nueva versión

1. En la rama `main`, cambie el número de versión de `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    En lugar de `patch`, use `minor` o `major`[según sea necesario](https://semver.org/).

    Tenga en cuenta que esto genera una etiqueta + confirmación de Git.

1. Inserte la confirmación y la etiqueta de versión:

    ```sh
    git push
    ```

    A continuación, nuestra CI publica automáticamente la nueva versión en npm.
