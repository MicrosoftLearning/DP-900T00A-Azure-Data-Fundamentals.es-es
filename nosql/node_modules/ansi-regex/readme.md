---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052621"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>[Estado de compilación![](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex) ansi-regex

> Expresión regular para buscar [códigos de escape ANSI](http://en.wikipedia.org/wiki/ANSI_escape_code) coincidentes


## <a name="install"></a>Instalar

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>Uso

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>Preguntas más frecuentes

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>¿Por qué se prueban los códigos no en el estándar ECMA 48?

Algunos de los códigos que ejecutamos como prueba son códigos que adquirimos para encontrar varias listas de códigos específicos de fabricante o no estándar. Si lo recuerdo correctamente, hicimos pruebas para códigos estándar y no estándar, ya que la mayoría de ellos siguen el mismo formato o similares y se pueden comparar de forma segura en cadenas sin el riesgo de quitar contenido de cadena real. Hay algunos códigos de control no estándar que no siguen el formato tradicional (es decir, terminan en números), lo que nos obliga a excluirlos de la prueba porque no podemos igualarlos de forma confiable.

En el historial, esos estándares ECMA se establecieron a principios de los noventa, mientras que el VT100, por ejemplo, se diseñó a mediados y finales de los setenta. En ese momento, los códigos de control todavía no estaban muy controlados y los ingenieros los usaban para una multitud de cosas, es decir, para activar puertos de hardware que pueden haber sido propios. En otro lugar verá una "anarquía" similar de códigos en la arquitectura x86 para procesadores; hay bastantes "interrupciones" que pueden significar cosas diferentes en ciertas marcas de procesadores, la mayoría de las cuales se han eliminado por fases.


## <a name="license"></a>Licencia

MIT © [Sindre Sorhus](http://sindresorhus.com)
