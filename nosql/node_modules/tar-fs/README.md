---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051970"
---
# <a name="tar-fs"></a>tar-fs

enlaces del sistema de archivos para [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![estado de la compilación](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>Uso

tar-fs permite empaquetar directorios en tarballs y extraer tarballs en directorios.

No es gunzip para usted, por lo que si quiere extraer `.tar.gz` con esto tendrá que usar algo como [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) además de esto.

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

Para omitir varios archivos al empaquetar o extraer, agregue una función ignore a las opciones. `ignore` también es un alias para `filter`. Además, puede obtener `header` si usa ignore durante la extracción.
De este modo, también puede filtrar por metadatos.

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

También puede especificar qué entradas empaquetar mediante la opción `entries`

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

Si desea modificar los encabezados al empaquetar o extraer, agregue una función map a las opciones

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

Del mismo modo, puede usar `mapStream` en caso de que desee modificar el flujo de archivos de entrada y salida

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Establezca `options.fmode` y `options.dmode` para asegurarse de que los archivos o directorios extraídos tienen los modos correspondientes

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

Puede ser útil usar `dmode` y `fmode` si va a empaquetar o desempaquetar tarballs entre *nix/windows para asegurarse de que todos los archivos o directorios desempaquetados sean legibles.

Como alternativa, puede establecer `options.readable` o `options.writable` para establecer el dmode y fmode en legible/grabable.

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Establezca `options.strict` en `false` si desea omitir los errores debido a tipos de entrada no admitidos (como archivos de dispositivo)

Para desreferenciar vínculos simbólicos (empaquetar el contenido del vínculo simbólico en lugar del propio vínculo), establezca `options.dereference` en `true`.

## <a name="copy-a-directory"></a>Copia de un directorio

Copiar un directorio con permisos y mtime intacto es tan sencillo como

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>Interacción con [`tar-stream`](https://github.com/mafintosh/tar-stream)

Use `finalize: false` y el enlace `finish` para dejar abierta la secuencia del paquete para obtener más entradas (consulte [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)) y use `pack` para pasar una secuencia de paquete existente.

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>Rendimiento

Empaquetar y extraer 6,1 GB con 2496 directorios y 2398 archivos produce los siguientes resultados en mi Macbook Air.
[Consulte el punto de referencia aquí](https://gist.github.com/mafintosh/8102201)

* tar-fs: 34 261 segundos
* [node-tar](https://github.com/isaacs/node-tar): 366 123 segundos (o 10 veces más lento)

## <a name="license"></a>Licencia

MIT
