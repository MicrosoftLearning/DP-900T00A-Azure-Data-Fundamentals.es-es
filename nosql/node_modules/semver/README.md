---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051976"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>SemVer(1): el versionamiento semántico para npm
===========================================

## <a name="install"></a>Instalar

```bash
npm install --save semver
````

## <a name="usage"></a>Uso

Como módulo de nodo:

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

Como utilidad de línea de comandos:

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>Versiones

Una "versión" se describe mediante la especificación `v2.0.0` que se encuentra en <https://semver.org/>.

Un carácter inicial `"="` o `"v"` se quita y se omite.

## <a name="ranges"></a>Intervalos

`version range` es un conjunto de `comparators` que especifica las versiones que cumplen el rango.

`comparator` se compone de `operator` y `version`.  El conjunto de `operators` primitivos es el siguiente:

* `<` Menor que
* `<=` Menor o igual que
* `>` Mayor que
* `>=` Mayor o igual que
* `=` Igual.  Si no se especifica ningún operador, se asume la igualdad, por lo que este operador es opcional, pero PUEDE incluirse.

Por ejemplo, el comparador `>=1.2.7` coincidiría con las versiones `1.2.7`, `1.2.8`, `2.5.3` y `1.3.9`, pero no con las versiones `1.2.6` o `1.1.0`.

Los comparadores se pueden unir mediante un espacio en blanco para formar `comparator set`, que se cumple mediante la **intersección** de todos los comparadores que incluye.

Un rango se compone de uno o varios conjuntos de comparadores, unidos por `||`.  Una versión coincide con un rango solo si cada comparador de al menos uno de los conjuntos de comparadores separados por `||` cumple con la versión.

Por ejemplo, el rango `>=1.2.7 <1.3.0` coincidiría con las versiones `1.2.7`, `1.2.8` y `1.2.99`, pero no con las versiones `1.2.6`, `1.3.0` o `1.1.0`.

El rango `1.2.7 || >=1.2.9 <2.0.0` coincidiría con las versiones `1.2.7`, `1.2.9` y `1.4.6`, pero no con las versiones `1.2.8` o `2.0.0`.

### <a name="prerelease-tags"></a>Etiquetas de versión preliminar

Si una versión tiene una etiqueta de versión preliminar (por ejemplo, `1.2.3-alpha.3`), solo se le permitirá cumplir los conjuntos de comparadores si al menos un comparador con la misma tupla `[major, minor, patch]` también tiene una etiqueta de versión preliminar.

Por ejemplo, el intervalo `>1.2.3-alpha.3` podría coincidir con la versión `1.2.3-alpha.7`, pero *no* cumpliría con `3.4.5-alpha.9`, aunque `3.4.5-alpha.9` técnicamente sea "mayor que" `1.2.3-alpha.3` según las reglas de ordenación de SemVer.  El intervalo de versiones solo acepta etiquetas de versión preliminar en la versión `1.2.3`.  La versión `3.4.5` *cumpliría* el rango, porque no tiene una marca de versión preliminar y `3.4.5` es mayor que `1.2.3-alpha.7`.

El propósito de este comportamiento es doble.  En primer lugar, las versiones preliminares a menudo se actualizan con mucha rapidez y contienen muchos cambios importantes que (por el diseño del autor) aún no son aptos para el consumo público.
Por lo tanto, de forma predeterminada, se excluyen de la semántica de coincidencia de rangos.

En segundo lugar, un usuario que ha optado por usar una versión preliminar ha indicado claramente la intención de usar ese conjunto *específico* de versiones alfa/beta/rc.  Al incluir una etiqueta de versión preliminar en el rango, el usuario indica que es consciente del riesgo.  Pero, todavía no es adecuado suponer que han optado por asumir un riesgo similar en el *siguiente* conjunto de versiones preliminares.

Tenga en cuenta que este comportamiento se puede suprimir (tratando todas las versiones preliminares como si fueran versiones normales, para la coincidencia de rangos) estableciendo la marca `includePrerelease` en el objeto options en cualquier [función](https://github.com/npm/node-semver#functions) que coincida con el rango.

#### <a name="prerelease-identifiers"></a>Identificadores de versión preliminar

El método `.inc` toma un argumento de cadena adicional `identifier` que anexará el valor de la cadena como identificador de versión preliminar:

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

ejemplo de línea de comandos:

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Que se puede usar a continuación para incrementar aún más:

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>Sintaxis de rango avanzada

La sintaxis de rango avanzada desazucara los comparadores primitivos de maneras deterministas.

Los rangos avanzados pueden combinarse de la misma forma que los comparadores primitivos mediante un espacio en blanco o `||`.

#### <a name="hyphen-ranges-xyz---abc"></a>Rangos de guion `X.Y.Z - A.B.C`

Especifica un conjunto inclusivo.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

Si se proporciona una versión parcial como la primera versión del rango inclusivo, las partes que faltan se reemplazan por ceros.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

Si se proporciona una versión parcial como la segunda versión del rango inclusivo, se aceptan todas las versiones que comienzan por las partes proporcionadas por la tupla, pero nada que sea mayor que dichas partes.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>Rangos de X `1.2.x` `1.X` `1.2.*` `*`

Cualquiera de `X`, `x`o `*` se puede usar para "permanecer" en uno de los valores numéricos de la tupla `[major, minor, patch]`.

* `*` := `>=0.0.0` (Cualquier versión cumple)
* `1.x` := `>=1.0.0 <2.0.0` (Versión principal coincidente)
* `1.2.x` := `>=1.2.0 <1.3.0` (Versiones principal y secundaria coincidentes)

Un rango de versiones parcial se trata como un rango de X, por lo que el carácter especial es opcional.

* `""` (cadena vacía) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>Rangos de tilde `~1.2.3` `~1.2` `~1`

Permite cambios de nivel de revisión si se especifica una versión secundaria en el comparador.  Si no, permite cambios de nivel secundario.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (Igual que `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (Igual que `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (Igual que `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (Igual que `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Tenga en cuenta que se permitirán las versiones preliminares de la versión `1.2.3`, si son mayores o iguales que `beta.2`.  Por lo tanto, `1.2.3-beta.4` se permitiría, pero `1.2.4-beta.2` no, porque es una versión preliminar de una tupla `[major, minor, patch]` diferente.

#### <a name="caret-ranges-123-025-004"></a>Rangos de cursor de inserción `^1.2.3` `^0.2.5` `^0.0.4`

Permite cambios que no modifican el dígito izquierdo distinto de cero en la tupla `[major, minor, patch]`.  En otras palabras, esto permite actualizaciones de revisión y secundarias para las versiones `1.0.0` y posteriores, las actualizaciones de revisiones para las versiones `0.X >=0.1.0` y *ninguna* actualización para las versiones `0.0.X`.

Muchos autores tratan una versión `0.x` como si `x` fuera el indicador principal de "cambio importante".

Los rangos de cursor de inserción son ideales cuando un autor puede realizar cambios importantes entre las versiones `0.2.4` y `0.3.0`, que es una práctica común.
Pero, supone que *no* habrá cambios importantes entre `0.2.4` y `0.2.5`.  Permite cambios que se supone que son aditivos (pero no importantes), según las prácticas observadas habitualmente.

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Tenga en cuenta que se permitirán las versiones preliminares en la versión `1.2.3`, si son mayores o iguales que `beta.2`.  Por lo tanto, `1.2.3-beta.4` se permitiría, pero `1.2.4-beta.2` no, porque es una versión preliminar de una tupla `[major, minor, patch]` diferente.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Tenga en cuenta que *solo* se permitirán las versiones preliminares en la versión `0.0.3`, si son mayores o iguales que `beta`.  Por lo tanto, `0.0.3-pr.2` se permitiría.

Al analizar los rangos de cursor de inserción, un valor `patch` que falta desazucara el número `0`, pero permitirá flexibilidad dentro de ese valor, incluso si las versiones principales y secundarias son ambas `0`.

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

Valores `minor` y `patch` que faltan desazucararán a cero, pero también permitirán flexibilidad dentro de esos valores, incluso si la versión principal es cero.

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>Gramática de rangos

Juntando todo esto, esta es una gramática Backus-Naur para rangos, para el beneficio de los autores del analizador:

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>Functions

Todos los métodos y clases toman un argumento de objeto `options` final.  Todas las opciones de este objeto son `false` de forma predeterminada.  Las opciones admitidas son las siguientes:

- `loose`  Sea más indulgente con las cadenas de SemVer no tan válidas.
  (Cualquier salida resultante siempre será 100 % estricta con la compatibilidad, por supuesto).  Por motivos de compatibilidad con versiones anteriores, si el argumento `options` es un valor booleano en lugar de un objeto, se interpreta como parámetro `loose`.
- `includePrerelease`  Establézcalo para suprimir el [comportamiento predeterminado](https://github.com/npm/node-semver#prerelease-tags) de excluir las versiones etiquetadas de versión preliminar de los rangos a menos que participen explícitamente.

Los comparadores y rangos de modo estricto serán estrictos sobre las cadenas de SemVer que analizan.

* `valid(v)`: devuelve la versión analizada o NULL si no es válida.
* `inc(v, release)`: devuelve la versión incrementada por el tipo de versión (`major`,   `premajor`, `minor``preminor`, `patch`, `prepatch` o `prerelease`) o NULL si no es válida
  * `premajor` en una llamada aumentará la versión hasta la siguiente versión principal y hasta una versión preliminar de esa versión principal.
    `preminor` y `prepatch` funcionan de la misma forma.
  * Si se llama desde una versión no preliminar, `prerelease` funcionará igual que `prepatch`. Incrementa la versión de revisión, después realiza una versión preliminar. Si la versión de entrada ya es una versión preliminar, simplemente la incrementa.
* `prerelease(v)`: devuelve una matriz de componentes de versión preliminar o NULL si no existe ninguno. Ejemplo: `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`: devuelve el número de versión principal.
* `minor(v)`: devuelve el número de versión secundaria.
* `patch(v)`: devuelve el número de versión de revisión.
* `intersects(r1, r2, loose)`: devuelve true si los dos rangos o comparadores proporcionados forman intersección.
* `parse(v)`: intenta analizar una cadena como una versión semántica y devuelve un objeto `SemVer` o `null`.

### <a name="comparison"></a>De comparación

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`: `v1 == v2` esto es true si son lógicamente equivalentes, incluso si no son la misma cadena.  Ya sabe cómo comparar cadenas.
* `neq(v1, v2)`: `v1 != v2` lo contrario de `eq`.
* `cmp(v1, comparator, v2)`: pase una cadena de comparación y llamará a la función correspondiente anterior.  `"==="` y `"!=="` realizan una comparación de cadenas sencilla, pero se incluyen por integridad.  Se produce si se proporciona una cadena de comparación no válida.
* `compare(v1, v2)`: devuelve `0` si `v1 == v2` o `1` si `v1` es mayor o `-1` si `v2` es mayor.  Organiza en orden ascendente si se pasa a `Array.sort()`.
* `rcompare(v1, v2)`: la inversa de la comparación.  Organiza una matriz de versiones en orden descendente cuando se pasa a `Array.sort()`.
* `diff(v1, v2)`: devuelve la diferencia entre dos versiones por el tipo de versión (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` o `prerelease`) o NULL si las versiones son iguales.

### <a name="comparators"></a>Comparadores

* `intersects(comparator)`: devuelve true si los comparadores forman intersecciones

### <a name="ranges"></a>Intervalos

* `validRange(range)`: devuelve el rango válido o NULL si no es válido
* `satisfies(version, range)`: devuelve true si la versión cumple el rango.
* `maxSatisfying(versions, range)`: devuelve la versión más alta de la lista que cumple el rango o `null` si ninguna de ellas lo hace.
* `minSatisfying(versions, range)`: devuelve la versión más alta de la lista que cumple el rango o `null` si ninguna de ellas lo hace.
* `minVersion(range)`: devuelve la versión más baja que posiblemente pueda coincidir con el rango especificado.
* `gtr(version, range)`: devuelve `true` si la versión es mayor que todas las versiones posibles en el rango.
* `ltr(version, range)`: devuelve `true` si la versión es mayor que todas las versiones posibles en el rango.
* `outside(version, range, hilo)`: devuelve true si la versión está fuera de los límites del rango en dirección alta o baja.  El argumento `hilo` debe ser la cadena `'>'` o `'<'`.  (Esta es la función a la que llaman `gtr` y `ltr`).
* `intersects(range)`: devuelve true si alguno de los comparadores de rangos forma intersección

Tenga en cuenta que, dado que los rangos pueden ser no contiguos, es posible que una versión no sea mayor que un rango, menor que un rango *o* que cumpla un rango.  Por ejemplo, el intervalo `1.2 <1.2.9 || >2.0.0` tendría un agujero desde `1.2.9` hasta `2.0.0`, por lo que la versión `1.2.10` no sería mayor que el intervalo (porque `2.0.1` cumple, que es mayor), ni menor que el intervalo (ya que `1.2.8` cumple, que es inferior), y tampoco cumple el intervalo.

Si desea saber si una versión cumple o no un rango, use la función `satisfies(version, range)`.

### <a name="coercion"></a>Conversión

* `coerce(version)`: convierte una cadena en SemVer si es posible

El objetivo es proporcionar una traducción muy indulgente de una cadena no SemVer a SemVer. Busca el primer dígito de una cadena y consume todos los caracteres restantes que cumplan al menos un SemVer parcial (por ejemplo, `1`, `1.2`, `1.2.3`) hasta la longitud máxima permitida (256 caracteres).  Las versiones más largas simplemente se truncan (`4.6.3.9.2-alpha2` se convierte en `4.6.3`).  Todo el texto circundante simplemente se omite (`v3.4 replaces v3.3.1` se convierte en `3.4.0`).  Solo el texto que carece de dígitos producirá un error de coerción (`version one` no es válido).  La longitud máxima de cualquier componente de SemVer considerado para la coerción es de 16 caracteres; se omitirán los componentes más largos (`10000000000000000.4.7.4` se convierte en `4.7.4`).  El valor máximo de cualquier componente de SemVer es `Number.MAX_SAFE_INTEGER || (2**53 - 1)`; los componentes de mayor valor no son válidos (es probable que `9999999999999999.4.7.4` no sea válido).
