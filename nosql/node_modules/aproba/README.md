---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052693"
---
<a name="aproba"></a>aproba
======

Un validador de argumentos de función ridículamente ligero

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

Los tipos válidos son los siguientes:

| tipo | description
| :--: | :----------
| *    | coincide con cualquier tipo
| Un    | `Array.isArray` O un objeto `arguments`
| S    | typeof == string
| No    | typeof == number
| F    | typeof == function
| O    | typeof == object and not type A and not type E
| N    | typeof == boolean
| E    | `instanceof Error` O `null` **(especial: ver a continuación)**
| Z    | == `null`

Los errores de validación producen uno de los tres tipos de excepción, que se distinguen por una propiedad `code` de `EMISSINGARG`, `EINVALIDTYPE` o `ETOOMANYARGS`.

Si pasa un tipo no válido, se producirá con un código de `EUNKNOWNTYPE`.

Si se encuentra un argumento de **error** y no es NULL, los argumentos restantes son opcionales.  Es decir, si dice `ESO`, es como usar un elemento no mágico `E` en: `E|ESO|ZSO`.

### <a name="but-i-have-optional-arguments"></a>Pero, ¿tengo argumentos opcionales?

Puede proporcionar más de una firma separándolas con canalizaciones `|`.
Si alguna firma coincide con los argumentos, se considerarán válidas.

Por ejemplo, supongamos que quería escribir una firma para `fs.createWriteStream`.  Los documentos para ella la describen así:

```
fs.createWriteStream(path[, options])
```

Esto sería una firma de `SO|S`.  Es decir, una cadena y un objeto, o simplemente una cadena.

Ahora, si lee los documentos `fs` completos, verá que la ruta de acceso realmente también puede ser un búfer.  Y las opciones pueden ser una cadena, es decir:
```
path <String> | <Buffer>
options <String> | <Object>
```

Para reproducirlo, debe enumerar por completo todas las combinaciones posibles y eso implica una firma de `SO|SS|OO|OS|S|O`.  La dificultad es una característica: Le recuerda la complejidad que está agregando a la API al hacer este tipo de cosas.


### <a name="browser-support"></a>Compatibilidad con exploradores

Esto no tiene dependencias y debe funcionar en exploradores, aunque tendrá los ruidosos seguimientos de la pila.

### <a name="why-this-exists"></a>¿Por qué existe?

Quería un validador de argumentos muy sencillo. Necesitaba hacer dos cosas:

1. Ser más conciso y más fácil de usar que las aserciones

2. No fomentar una serie infinita de DSL

Este es el motivo por el que los tipos se especifican mediante un solo carácter y no hay nada parecido a un argumento opcional. 

Esto no está pensado para validar los datos de usuario. Se trata específicamente de la aserción de la interfaz de las funciones.

Si necesita una validación más amplia, le animo a escribirla a mano o a buscar en otro lugar.

