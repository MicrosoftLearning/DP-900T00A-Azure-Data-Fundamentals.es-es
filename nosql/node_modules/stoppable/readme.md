---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052541"
---
# <a name="stoppable"></a>Stoppable

[![Estado de compilación](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> Node es `server.close()` la forma en que probablemente [espere que funcione de forma predeterminada](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Resumen

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable deja de aceptar nuevas conexiones y cierra las conexiones inactivas existentes (incluidas las de mantenimiento activo) sin eliminar las solicitudes que están en curso.

## <a name="requirements"></a>Requisitos

- Node.js v6+

Node.js v4.x no se admite *de forma no oficial*.

## <a name="installation"></a>Instalación

```bash
yarn add stoppable
```

(o use npm)

## <a name="usage"></a>Uso

**constructor**

```js
stoppable(server, grace)
```

Decora la instancia del servidor con un método `stop`.
Devuelve la instancia del servidor, por lo que se puede encadenar o se puede ejecutar como una instrucción independiente.

- servidor: Cualquier instancia de servidor HTTP o HTTPS
- gracia: milisegundos que se deben esperar antes de las conexiones de cierre forzado

`grace` el valor predeterminado es Infinity (no forzar el cierre).
Si desea matar inmediatamente todos los sockets, puede usar una gracia de 0.

**detener()**

```js
server.stop(callback)
```

Cierra el servidor.

- devolución de llamada: se pasa a la función existente `server.close` para registrar automáticamente un evento de "cierre".
El primer argumento es un error y el segundo argumento es un valor booleano que indica si se detuvo correctamente.

## <a name="design-decisions"></a>Decisiones de diseño

- La aplicación de revisiones de Monkey generalmente no es buena, pero en este caso es la API más agradable. Vamos a decir que está "decorada".
- `grace` se puede especificar en `stop`, pero es mejor que coincida con la API existente `server.close`.
- Los clientes deben controlarse respetuosamente, ya que no solo estamos destruyendo sockets, estamos enviando paquetes `FIN`.
- Cualquier solución a este problema requiere contabilidad en cada conexión y solicitud/respuesta.
Estamos trabajando de forma mínima en estas rutas de acceso de código "activas" y retrasando todo lo posible el método real `stop`.

## <a name="performance"></a>Rendimiento

No hay ninguna manera de proporcionar esta funcionalidad sin llevar el registro sobre la conexión, desconexión, solicitud y respuesta.
Sin embargo, Stoppable se esfuerza por realizar un trabajo mínimo en rutas de acceso de código activas y usar estructuras de datos óptimas.

Me interesaría ver las pruebas comparativas de rendimiento en un entorno real; la sencilla prueba de bucle invertido incluida en la biblioteca muestra muy poca sobrecarga del uso de un servidor de Stoppable:

### <a name="without-stoppable"></a>Sin Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Con Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Licencia

MIT